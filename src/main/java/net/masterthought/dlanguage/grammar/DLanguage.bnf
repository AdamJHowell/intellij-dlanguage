{
  parserClass="net.masterthought.dlanguage.parser.DLanguageParser"
  parserUtilClass="net.masterthought.dlanguage.parser.ParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="DLanguage"
  psiImplClassSuffix="Impl"
  psiPackage="net.masterthought.dlanguage.psi"
  psiImplPackage="net.masterthought.dlanguage.psi.impl"

  elementTypeHolderClass="net.masterthought.dlanguage.psi.DLanguageTypes"
  elementTypeClass="net.masterthought.dlanguage.psi.DLanguageElementType"
  tokenTypeClass="net.masterthought.dlanguage.psi.DLanguageTokenType"

  // used to attach custom methods into the classes - e.g. Identifier
  psiImplUtilClass="net.masterthought.dlanguage.psi.impl.DPsiImplUtil"


  // used to extend to use stubs
  extends("Identifier|LabeledStatement|FuncDeclaration|ClassDeclaration|InterfaceDeclaration|TemplateDeclaration|Constructor|StructDeclaration|AliasDeclarationSingle|AliasDeclarationY|ModuleDeclaration|TemplateMixinDeclaration|DeclaratorInitializer|AutoDeclarationY|UnionDeclaration|EnumDeclaration|Import|ConditionVariableDeclaration|ForeachType|CatchParameter|VarFuncDeclaration|Parameter|EnumMember|TemplateParameter|Destructor|StaticDestructor|StaticConstructor|SharedStaticDestructor|SharedStaticConstructor")="net.masterthought.dlanguage.psi.impl.DNamedStubbedPsiElementBase<?>"
  elementTypeFactory("Identifier|LabeledStatement|FuncDeclaration|ClassDeclaration|InterfaceDeclaration|TemplateDeclaration|Constructor|StructDeclaration|AliasDeclarationSingle|AliasDeclarationY|ModuleDeclaration|TemplateMixinDeclaration|DeclaratorInitializer|AutoDeclarationY|UnionDeclaration|EnumDeclaration|Import|UnitTesting|ConditionVariableDeclaration|ForeachType|CatchParameter|VarFuncDeclaration|Parameter|EnumMember|TemplateParameter|Destructor|StaticDestructor|StaticConstructor|SharedStaticDestructor|SharedStaticConstructor")="net.masterthought.dlanguage.psi.impl.DElementTypeFactory.factory"

  generateTokenAccessors=true

tokens = [
 KW_MODULE = "module"
 KW_IMPORT = "import"
 KW_STATIC = "static"
 KW_BOOL = "bool"
 KW_BYTE = "byte"
 KW_UBYTE = "ubyte"
 KW_SHORT = "short"
 KW_USHORT = "ushort"
 KW_INT = "int"
 KW_UINT = "uint"
 KW_LONG = "long"
 KW_ULONG = "ulong"
 KW_CHAR = "char"
 KW_WCHAR = "wchar"
 KW_DCHAR = "dchar"
 KW_FLOAT = "float"
 KW_DOUBLE = "double"
 KW_REAL = "real"
 KW_IFLOAT = "ifloat"
 KW_IDOUBLE = "idouble"
 KW_IREAL = "ireal"
 KW_CFLOAT = "cfloat"
 KW_CDOUBLE = "cdouble"
 KW_CREAL = "creal"
 KW_VOID = "void"
 KW_TYPEOF = "typeof"
 KW_CONST = "const"
 KW_IMMUTABLE = "immutable"
 KW_SHARED = "shared"
 KW_INOUT = "inout"
 KW_DELEGATE = "delegate"
 KW_FUNCTION = "function"
 KW_NOTHROW = "nothrow"
 KW_PURE = "pure"
 KW_THIS = "this"
 KW___FILE__ = "__FILE__"
 KW___MODULE__ = "__MODULE__"
 KW___LINE__ = "__LINE__"
 KW___FUNCTION__ = "__FUNCTION__"
 KW___PRETTY_FUNCTION__ = "__PRETTY_FUNCTION__"
 KW_ABSTRACT = "abstract"
 KW_ALIAS = "alias"
 KW_AUTO = "auto"
 KW_DEPRECATED = "deprecated"
 KW_ENUM = "enum"
 KW_EXTERN = "extern"
 KW_FINAL = "final"
 KW_OVERRIDE = "override"
 KW___GSHARED = "__gshared"
 KW_SCOPE = "scope"
 KW_SYNCHRONIZED = "synchronized"
 KW_RETURN = "return"
 KW_SUPER = "super"
 KW_ALIGN = "align"
 KW_PRAGMA = "pragma"
 KW_PACKAGE = "package"
 KW_PRIVATE = "private"
 KW_PROTECTED = "protected"
 KW_PUBLIC = "public"
 KW_EXPORT = "export"
 KW_DELETE = "delete"
 KW_NULL = "null"
 KW_TRUE = "true"
 KW_FALSE = "false"
 KW_NEW = "new"
 KW_TYPEID = "typeid"
 KW_IS = "is"
 KW_NOT_IS = "!is"
 KW_STRUCT = "struct"
 KW_UNION = "union"
 KW_CLASS = "class"
 KW_INTERFACE = "interface"
 KW___PARAMETERS = "__parameters"
 KW_IN = "in"
 KW_ASM = "asm"
 KW_ASSERT = "assert"
 KW_CASE = "case"
 KW_CAST = "cast"
 KW_REF = "ref"
 KW_BREAK = "break"
 KW_CONTINUE = "continue"
 KW_DO = "do"
 KW_ELSE = "else"
 KW_FOR = "for"
 KW_FOREACH = "foreach"
 KW_FOREACH_REVERSE = "foreach_reverse"
 KW_GOTO = "goto"
 KW_IF = "if"
 KW_CATCH = "catch"
 KW_FINALLY = "finally"
 KW_SWITCH = "switch"
 KW_THROW = "throw"
 KW_TRY = "try"
 KW_DEFAULT = "default"
 KW_WHILE = "while"
 KW_WITH = "with"
 KW_VERSION = "version"
 KW_DEBUG = "debug"
 KW_MIXIN = "mixin"
 KW_INVARIANT = "invariant"
 KW_BODY = "body"
 KW_TEMPLATE = "template"
 KW_LAZY = "lazy"
 KW_OUT = "out"
// KW_NOGC = "nogc"// not a reserved word
 KW___TRAITS = "__traits"
 KW_UNITTEST = "unittest"
 OP_SCOLON = ";"
 OP_COLON = ":"
 OP_EQ = "="
 OP_COMMA = ","
 OP_PAR_LEFT = "("
 OP_PAR_RIGHT = ")"
 OP_BRACKET_LEFT = "["
 OP_BRACKET_RIGHT = "]"
 OP_BRACES_LEFT = "{"
 OP_BRACES_RIGHT = "}"
 OP_ASTERISK = "*"
 OP_DDOT = ".."
 OP_TRIPLEDOT = "..."
 OP_AT = "@"
 OP_PLUS_EQ = "+="
 OP_MINUS_EQ = "-="
 OP_MUL_EQ = "*="
 OP_DIV_EQ = "/="
 OP_MOD_EQ = "%="
 OP_AND_EQ = "&="
 OP_OR_EQ = "|="
 OP_XOR_EQ = "^="
 OP_TILDA_EQ = "~="
 OP_SH_LEFT_EQ = "<<="
 OP_SH_RIGHT_EQ = ">>="
 OP_USH_RIGHT_EQ = ">>>="
 OP_POW_EQ = "^^="
 OP_QUEST = "?"
 OP_BOOL_OR = "||"
 OP_BOOL_AND = "&&"
 OP_OR = "|"
 OP_XOR = "^"
 OP_SH_LEFT = "<<"
 OP_SH_RIGHT = ">>"
 OP_USH_RIGHT = ">>>"
 OP_PLUS = "+"
 OP_MINUS = "-"
 OP_TILDA = "~"
 OP_DIV = "/"
 OP_MOD = "%"
 OP_AND = "&"
 OP_PLUS_PLUS = "++"
 OP_MINUS_MINUS = "--"
 OP_NOT = "!"
 OP_POW = "^^"
 OP_DOLLAR = "$"
 OP_EQ_EQ = "=="
 OP_NOT_EQ = "!="
 OP_LESS = "<"
 OP_LESS_EQ = "<="
 OP_GT = ">"
 OP_GT_EQ = ">="
 OP_UNORD = "!<>="
 OP_UNORD_EQ = "!<>"
 OP_LESS_GR = "<>"
 OP_LESS_GR_EQ = "<>="
 OP_NOT_GR = "!>"
 OP_NOT_GR_EQ = "!>="
 OP_NOT_LESS = "!<"
 OP_NOT_LESS_EQ = "!<="
 OP_LAMBDA_ARROW = "=>"
 OP_DOT = "."
 SHEBANG = "shebang"

 LINE_COMMENT="LINE_COMMENT"
 BLOCK_COMMENT="BLOCK_COMMENT"
 NESTING_BLOCK_COMMENT="NESTING_BLOCK_COMMENT"
 TOKEN_STRING = "TOKEN_STRING"


// Comment these back in when playing with Live Preview
// ------------------------
ID = "regexp:\w+"
space='regexp:\s+'
line_comment="regexp://.*"
block_comment="regexp:/\*(.|\n)*\*/"
DOUBLE_QUOTED_STRING = 'regexp:\"([^\\"]|((\\"|\\\?|\\\|\\0|\\a|\\b|\\f|\\n|\\r|\\t|\\v)|(\\x[0-9abcdefABCDEF_]{2})|(\\[0-7])|(\\[0-7]{2})|(\\[0-7]{3})|(\\u[0-9abcdefABCDEF_]{4})|(\\U[0-9abcdefABCDEF_]{8})|(\\&([a-zA-Z_])([a-zA-Z0-9_])*;)))*\"[cwd]*'
//FLOAT_LITERAL = "regexp:[0-9][0-9_]*\.([0]|[1-9_][0-9_]*)?"
//CHARACTER_LITERAL="regexp:\'([^\r\n\t\f\\])\'"
////DECIMAL_FLOAT_SIMPLE ="regexp:[0-9][0-9_]*\.([0]|[1-9_][0-9_]*)?!\."
//DECIMAL_FLOAT_EXPONENT = "regexp:[0-9_]+\.[0-9_]+[eE][\+\-]? [0-9_]+"
//DECIMAL_FLOAT_FIRST_DOT = "regexp:\. ([0] | [1-9_] [0-9_]*)"
//DECIMAL_FLOAT_FIRST_DOT_EXPONENT = "regexp:\. ([0] | [1-9] [0-9]*) [eE][\+\-]? [0-9_]+"
//DECIMAL_FLOAT_NO_DOT_EXPONENT = "regexp:[0-9] [0-9_]* [eE][\+\-]? [0-9_]+"
//// ------------------------

 ]

}

dFile ::= item_*

private item_ ::= (ModuleDeclaration | DeclDefs | Statement | SHEBANG ) {
    recoverWhile = item_recover
}

private item_recover ::= !( ModuleDeclaration | DeclDefs | Statement | SHEBANG )

Identifier ::= ID {
    methods=[getName getNameIdentifier getReference setName getPresentation delete]
    stubClass="net.masterthought.dlanguage.stubs.DLanguageIdentifierStub"
    implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement"]
    }

StringLiteral  ::= (WYSIWYG_STRING|ALTERNATE_WYSIWYG_STRING|DOUBLE_QUOTED_STRING|HEX_STRING|DELIMITED_STRING| (TOKEN_STRING TOKEN_STRING*))


// Module

ModuleDeclaration ::=
    Attribute? 'module' ModuleFullyQualifiedName ';'{
        pin = 2
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageModuleDeclarationStub"
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.GlobalDeclarationContainer" "net.masterthought.dlanguage.psi.interfaces.Declaration" ]
    }

ModuleFullyQualifiedName ::=
    Identifier ['.' ModuleFullyQualifiedName] {
        recoverWhile = module_name_recover
        pin = 1
    }

private module_name_recover ::= !(/*Identifier*/ ':' | ',' |  ';')

// Import

ImportDeclaration ::=
    RegularImport |
    StaticImport

private RegularImport ::=
    'import' ImportList ';'
    {
        pin = 1
    }

private StaticImport ::=
    'static' 'import' ImportList ';'
    {
        pin = 2
    }

ImportList ::=
    Import (':' ImportBindList | ',' ImportList)?

Import ::=
    (Identifier '=')? ModuleFullyQualifiedName{
     methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
     pin = 2
     stubClass="net.masterthought.dlanguage.stubs.DLanguageImportDeclarationStub"
     implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility"]
  }

ImportBindList ::=
    ImportBind (',' ImportBindList)?

ImportBind ::=
    Identifier ('=' Identifier)?

DeclDefs ::= DeclDef DeclDef*{
    pin = 1
    methods = [processDeclarations]
}

//order matters
DeclDef ::=
    (AttributeSpecifier
    | Declaration
    | Postblit
    | Constructor
    | Destructor
    | Allocator
    | Deallocator
    | Invariant
    | UnitTesting
    | AliasThis
    | StaticConstructor
    | StaticDestructor
    | SharedStaticConstructor
    | SharedStaticDestructor
    | ConditionalDeclaration
    | DebugSpecification
    | VersionSpecification
    | StaticAssert
    | TemplateDeclaration
    | TemplateMixinDeclaration
    | TemplateMixin
    | MixinDeclaration
    | StaticIfCondition
    | StaticElseCondition
    | ';'
    ){
        methods = [processDeclarations]
    }

MixinDeclaration ::=
    'mixin' '(' ((TemplateInstance AssignExpression?)| AssignExpression) ')' ';'{
    //the extra AssignExpression after the TemplateInstance is for statements like:
    //mixin(ImplementClassImpl!(Class, typeof(this))());
    //todo check if this is still true
     methods = [getName /*processDeclarations*/]
     implements = ["net.masterthought.dlanguage.psi.interfaces.Mixin"]
    }

//external external_type ::= parseType
//Type ::=  TypeCtors <<external_type false>>
TypeCtors ::=
    TypeCtor*

TypeCtor ::=
    'const'
    | 'immutable'
    | 'shared'
    | 'inout'

Type ::=
    TypeCtors? BasicType BasicType2?


BasicType ::=
    BasicTypeX
    | (
        ('this' BasicTypeX)
        | ('super' BasicTypeX)
        | (TemplateInstance)
        | (Identifier BasicTypeX)
    )
    | '.' BasicType
    | 'typeof' ( BasicType )
    | TypeVector
    | TypeCtor '(' Type ')'

BasicTypeX ::=
    'void'
    | 'bool'
    | 'byte'
    | 'ubyte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    | 'wchar'
    | 'dchar'
    | 'float'
    | 'double'
    | 'real'
    | 'ifloat'
    | 'idouble'
    | 'ireal'
    | 'cfloat'
    | 'cdouble'
    | 'creal'
    //todo add any missing types

// See https://issues.dlang.org/show_bug.cgi?id=1215
// A basic type can look like MyType (typical case), but also:
//  MyType.T -> A type
//  MyType[expr] -> Either a static array of MyType or a type (iif MyType is a Ttuple)
//  MyType[expr].T -> A type.
//  MyType[expr].T[expr] ->  Either a static array of MyType[expr].T or a type
//                           (iif MyType[expr].T is a Ttuple)
BasicType3 ::=
    '.' Identifier
    | '[' ']'
    | '[' Type ']'
    | '[' AssignExpression ']'
    | '[' AssignExpression '..' AssignExpression ']'



BasicTypeWithArray ::=


BasicType2 ::=
    BasicType2X BasicType2?

BasicType2X ::=
    '*'
    | '[' Type? ']'
    | '[' AssignExpression ']'
    | '[' AssignExpression '..' AssignExpression ']'
    | 'delegate' Parameters MemberFunctionAttributes?
    | 'function' Parameters FunctionAttributes?
//todo these parameters might need a processDeclarations statement
*/
IdentifierList ::=
     Identifier TemplateInstance? ['.' IdentifierList]
    |  Identifier '[' AssignExpression ']' '.' IdentifierList

Typeof ::=
    'typeof' '(' (Expression | 'return') ')'{
    pin = 1
    }

TypeVector ::=
    '__vector' '(' Type')'{//todo add missing tokens
    pin = 1
    }

private Expression ::=
    CommaExpression

CommaExpression ::=
    AssignExpression (',' AssignExpression)*

AssignExpression ::=
   (ConditionalExpression [ ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '~=' | '<<=' | '>>=' | '>>>=' | '^^=') AssignExpression])

private ConditionalExpression ::=
   OrOrExpression_ [ConditionalExpression_]

ConditionalExpression_ ::=//
    '?' Expression ':' ConditionalExpression

private OrOrExpression_ ::=
    AndAndExpression [ OrOrExpression]

OrOrExpression ::=
    '||' OrOrExpression_

private AndAndExpression ::=
    '&&'? (OrExpression | CmpExpression) [AndAndExpression]

private OrExpression ::=
    XorExpression [OrExpression]

private XorExpression ::=
    AndExpression [ XorExpression_ ]

XorExpression_ ::= '^' XorExpression

private AndExpression ::=
    ShiftExpression [ AndExxpression_ ]

AndExxpression_ ::= '&' AndExpression

private CmpExpression ::=
    ShiftExpression
    | EqualExpression
    | IdentityExpression
    | RelExpression
    | InExpression

EqualExpression ::=
     ('==' | '!=') [ShiftExpression]{
     pin = 1
     }

IdentityExpression ::=
     ('is'|'!is') (ShiftExpression | AssignExpression){
     pin = 1
     }

RelExpression ::=
    ('<' | '<=' | '>' | '>=' | '!<>=' | '!<>' | '<>' | '<>=' | '!>' | '!>=' | '!<' | '!<=') ShiftExpression{
    pin = 1
    }

InExpression ::=
    ('in'| ('!''in')) ShiftExpression{
    pin = 1
    }

private ShiftExpression ::=
    AddExpression [ShiftExpression_]

ShiftExpression_ ::= ('<<' | '>>' | '>>>') ShiftExpression

private AddExpression ::=
    MulExpression [ AddExpression_]

AddExpression_ ::= ('+' | '-' | '~') AddExpression

private MulExpression ::=
    UnaryExpression [ MulExpression_ ]

MulExpression_ ::= ('*' | '/' | '%') MulExpression

private UnaryExpression ::=
     ('&'
    | '++'
    | '|'
    | '^^'
    | '--'
    | '*'
    | '-'
    | '+'
    | '!'
    | '~') [UnaryExpression]
    | TypeCtor? '(' Type ')' '.' Identifier
    | TypeCtor? '(' Type ')' '.' TemplateInstance
    | DeleteExpression
    | CastExpression
    | PowExpression

NewExpression ::=
    'new' AllocatorArguments? Type
    | NewExpressionWithArgs

NewExpressionWithArgs ::=
    'new' AllocatorArguments? Type '[' AssignExpression ']'
   | 'new' AllocatorArguments? Type ('(' ArgumentList? ')')?
   | NewAnonClassExpression

AllocatorArguments ::=
    '(' ArgumentList? ')'

ArgumentList ::=
    ArgumentListMember (','  ArgumentListMember)* ','?

private ArgumentListMember ::=
   AssignExpression

NewAnonClassExpression ::=
    'new' AllocatorArguments? 'class' ClassArguments? SuperClass? Interfaces? AggregateBody{
    pin = 1
    }

ClassArguments ::=
    '(' ArgumentList? ')'

DeleteExpression ::=
    'delete' UnaryExpression

CastExpression ::=
    'cast' '(' Type ')' UnaryExpression
    | 'cast' '(' TypeCtors? ')' UnaryExpression

private PowExpression ::=
    PostfixExpression [PowExpression_]

PowExpression_ ::= '^^' UnaryExpression PowExpression

PostfixExpression ::=
    PrimaryExpression
    | '.' Identifier [PostfixExpression]
    | '.' TemplateInstance [PostfixExpression]
    | '.' NewExpression [PostfixExpression]
    | '++' [PostfixExpression]
    |  '--' [PostfixExpression]
    | '(' ArgumentList? ')' [PostfixExpression]
    | TypeCtors? BasicType '(' ArgumentList? ')' [PostfixExpression]
    | IndexExpression
    | SliceExpression

IndexExpression ::=
     '[' ArgumentList ']' [PostfixExpression]{
     pin = 3
     }

SliceExpression ::=
     '[' ']' [PostfixExpression]
    |  '[' MultipleAssign ']' [PostfixExpression]

MultipleAssign ::=
 ((( (AssignExpression '..')) AssignExpression) | AssignExpression) [',' MultipleAssign ]

PrimaryExpression ::=
     ('.')? (TemplateInstance | Identifier)
    | FunctionLiteral //must be above ( Expression) and Type
    | Type
    | 'this'
    | 'super'
    | 'null'
    | 'true'
    | 'false'
    | '$'
    | INTEGER_LITERAL
    | FLOAT_LITERAL
    | CHARACTER_LITERAL
    | StringLiterals
    | ArrayLiteral
    | AssocArrayLiteral
    | AssertExpression
    | MixinExpression
    | ImportExpression
    | NewExpressionWithArgs
    | BasicTypeX '.' Identifier
    | Typeof
    | TypeidExpression
    | IsExpression
    | '(' Expression ')'
    | TraitsExpression
    | SpecialKeyword

StringLiterals ::= StringLiteral StringLiteral*


ArrayLiteral ::=
    '[' ArgumentList? ','? ']'

AssocArrayLiteral ::=
    '[' KeyValuePairs ']'

KeyValuePairs ::=
    KeyValuePair ((',') KeyValuePair)*

KeyValuePair ::=
    AssignExpression ':' AssignExpression

FunctionLiteral ::=
     'function' Type? ParameterAttributes? FunctionLiteralBody?
    | 'delegate' Type? ParameterMemberAttributes? FunctionLiteralBody?
    | ParameterMemberAttributes FunctionLiteralBody//Body cannot be optional
    | FunctionLiteralBody
    | Lambda
    {
        methods = [processDeclarations]
    }


ParameterAttributes ::=
    Parameters FunctionAttributes?//todo make this rule private, it simplifies scope processing logic

ParameterMemberAttributes ::=
    Parameters MemberFunctionAttributes?//todo make this rule private, it simplifies scope processing logic

FunctionLiteralBody ::=
    BlockStatement
    | Property* BlockStatement
    | FunctionContracts BodyStatement?

Lambda ::=
    'function' Type? ParameterAttributes '=>' AssignExpression
    | 'delegate' Type? ParameterMemberAttributes '=>' AssignExpression
    | ParameterMemberAttributes '=>' AssignExpression
    | Identifier? '=>' AssignExpression//todo that identifier shouldn't be optional and should be resolvable
    {
        methods = [processDeclarations]
    }

AssertExpression ::=
    'assert' '(' AssignExpression (',' AssignExpression)? ')'{
    pin = 1
    }

MixinExpression ::=
    'mixin' '(' ( AssignExpression) ')'
    {
        methods = [ getName /*processDeclarations */]
        implements = ["net.masterthought.dlanguage.psi.interfaces.Mixin"]
    }

ImportExpression ::=
    'import' '(' AssignExpression ')'
    {
        pin = 1//todo is this pin really necessary?
    }

TypeidExpression ::=
    TypeidExpressionType
    | TypeidExpressionExpression

private TypeidExpressionType ::=
    'typeid' '(' Type ')'{
        pin = 4//todo remove this
    }

private  TypeidExpressionExpression ::=
    'typeid' '(' Expression ')'{
        pin = 3
    }


IsExpression ::= ('is' | '!is') IsExpressionSuffix

private IsExpressionSuffix ::=
     '(' Type ')'
    | '(' Type ':' TypeSpecialization ')'
    | '(' Type '==' TypeSpecialization ')'
    | '(' Type ':' TypeSpecialization ',' TemplateParameterList ')'
    | '(' Type '==' TypeSpecialization ',' TemplateParameterList ')'
    | '(' Type Identifier ')'
    | '(' Type Identifier ':' TypeSpecialization ')'
    | '(' Type Identifier '==' TypeSpecialization ')'
    | '(' Type Identifier ':' TypeSpecialization ',' TemplateParameterList ')'
    | '(' Type Identifier '==' TypeSpecialization ',' TemplateParameterList ')'

TypeSpecialization ::=
    TypeVector
    | Type
    | 'struct'
    | 'union'
    | 'class'
    | 'interface'
    | 'enum'
    | 'function'
    | 'delegate'
    | 'super'
    | 'const'
    | 'immutable'
    | 'inout'
    | 'shared'
    | 'return'
    | '__parameters'

TraitsExpression ::=
    '__traits' ('(' TraitsKeyword ',' TraitsArguments ')')?
    {
        pin = 1
    }

TraitsKeyword ::=
    'isAbstractClass'
    | 'isTemplate'
    | 'isArithmetic'
    | 'isAssociativeArray'
    | 'isFinalClass'
    | 'isPOD'
    | 'isNested'
    | 'isFloating'
    | 'isIntegral'
    | 'isScalar'
    | 'isStaticArray'
    | 'isUnsigned'
    | 'isVirtualFunction'
    | 'isVirtualMethod'
    | 'isAbstractFunction'
    | 'isFinalFunction'
    | 'isStaticFunction'
    | 'isOverrideFunction'
    | 'isRef'
    | 'isOut'
    | 'isLazy'
    | 'hasMember'
    | 'identifier'
    | 'getAliasThis'
    | 'getAttributes'
    | 'getFunctionAttributes'
    | 'getMember'
    | 'getOverloads'
    | 'getProtection'
    | 'getPointerBitmap'
    | 'isSomeVisibility'
    | 'getVirtualFunctions'
    | 'getVirtualMethods'
    | 'getUnitTests'
    | 'parent'
    | 'classInstanceSize'
    | 'getVirtualIndex'
    | 'allMembers'
    | 'derivedMembers'
    | 'isSame'
    | 'compiles'

TraitsArguments ::=
    TraitsArgument (',' TraitsArguments)*

TraitsArgument ::=
    AssignExpression
    | Type

SpecialKeyword ::=
     '__FILE__'
    | '__MODULE__'
    | '__LINE__'
    | '__FUNCTION__'
    | '__PRETTY_FUNCTION__'

// Statement

Statement ::=
    ';'
    | NonEmptyStatement
    | BlockStatement
    {
        recoverWhile = statement_recover
        methods = [processDeclarations]
    }

private statement_recover ::=
    !('else' | Statement | '}' | DeclDef | ModuleDeclaration | 'catch' | 'finally' | ':' | ','| 'foreach' | SHEBANG | <<eof>>)//idk why the 'foreach' is needed todo


NonEmptyStatement ::=
    NonEmptyStatementNoCaseNoDefault
    | CaseRangeStatement//must be above case statement because pin on case statement will detect a case statement, where there is a case range statement
    | CaseStatement
    | DefaultStatement

private NonEmptyStatementNoCaseNoDefault ::=
    LabeledStatement
    | DeclarationStatement
    | Declaration
    | BlockStatement // must be above expression statement
    | IfStatement
    | WhileStatement
    | DoStatement
    | ForStatement
    | ForeachStatement
    | SwitchStatement
    | FinalSwitchStatement
    | ContinueStatement
    | BreakStatement
    | ReturnStatement
    | GotoStatement
    | WithStatement
    | SynchronizedStatement
    | TryStatement
    | ScopeGuardStatement
    | ThrowStatement
    | AsmStatement
    | PragmaStatement
    | MixinStatement
    | ForeachRangeStatement
    | ConditionalStatement
    | StaticAssert
    | TemplateMixin
    | ImportDeclaration
    | ExpressionStatement

ScopeStatement ::=
    NonEmptyStatement
    | BlockStatement
    {
        methods= [processDeclarations]
    }

LabeledStatement ::=
    Identifier ':' Statement?
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation processDeclarations ]
        pin = 2
        stubClass="net.masterthought.dlanguage.stubs.DLanguageLabeledStatementStub"
        implements = [ "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" ]
    }


BlockStatement ::=
 '{' StatementList? '}'

StatementList ::=
    Statement Statement*
    {
        methods = [ processDeclarations ]
    }

ExpressionStatement ::=
    Expression ';'?

DeclarationStatement ::=
    StorageClasses? Declaration

IfStatement ::=
    'if' '(' IfCondition ')' ThenStatement ('else' ElseStatement)?
    {
        pin = 1
        methods = [processDeclarations]
    }

IfCondition ::=
    Expression
    | ConditionVariableDeclaration//should be above expression

ConditionVariableDeclaration ::=
    'auto' Identifier '=' Expression
    | TypeCtors Identifier '=' Expression
    | TypeCtors? BasicType Declarator '=' Expression
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation ]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageConditionVariableDeclarationStub"
        implements = [ "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration" "net.masterthought.dlanguage.psi.interfaces.Declaration" ]
    }

ThenStatement ::=
    ScopeStatement

ElseStatement ::=
    ScopeStatement

WhileStatement ::=
    'while' '(' Expression ')' ScopeStatement
    {
        //todo check that while statements can't contain falsy/truthy declaration
        pin = 1
        methods = [processDeclarations]//this need not exist if while(), cannot contain var declarations as described as the above todo
    }

DoStatement ::=
    'do' ScopeStatement 'while' '(' Expression ')' ';'
    {
        pin = 1
        methods = [processDeclarations]//same todo applies as for while statement
    }

ForStatement ::=
    'for' '(' Initialize Test? ';' Increment? ')' ScopeStatement
    {
        pin = 1
        methods = [processDeclarations]//process the initialize for, but not scope statement
    }

Initialize ::=
   Statement
   | ';'

Test ::=
    Expression

Increment ::=
    Expression

ForeachStatement ::=
    Foreach '(' ForeachTypeList ';' ForeachAggregate ')' Statement
    {
        methods = [processDeclarations]//process the foreach type list, but not the statement
    }

Foreach ::=
    'foreach'
    | 'foreach_reverse'

ForeachTypeList ::=
    ForeachType (',' ForeachType)*

ForeachType ::=
   ForeachTypeAttributes? Type? Identifier // this needs to be above for ForeachTypeAttributes? Type? Identifier
   | ForeachTypeAttribute Identifier
   | Type? ForeachTypeAttributes? Identifier
   | Identifier
   {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation ]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageForeachTypeStub"
        implements = [ "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
   }

ForeachTypeAttributes ::=
    ForeachTypeAttribute [ForeachTypeAttributes]

ForeachTypeAttribute ::=
    'ref'
    | TypeCtor

ForeachAggregate ::=
    Expression

ForeachRangeStatement ::=//todo remove this from grammar
    Foreach '(' ForeachType ';' LwrExpression '..' UprExpression ')' ScopeStatement
    {
        methods = [processDeclarations]//process foreach type
    }

LwrExpression ::=
    Expression

UprExpression ::=
    Expression

SwitchStatement ::=
    'switch' '(' Expression ')' ScopeStatement
    {
        pin = 1
        //no need for processing declarations, since switch's have there own scope
    }

CaseStatement ::=
    'case' ArgumentList ':' ScopeStatementList?
    {
        pin = 3
        //no need for processing declarations, since each case have there own scope
    }

CaseRangeStatement ::=
    'case' FirstExp ':' '..' 'case' LastExp ':' StatementList
    {
        pin = 4
        //no need for processing declarations, since each case have there own scope
    }

FirstExp ::=
    AssignExpression

LastExp ::=
    AssignExpression

DefaultStatement ::=
    'default' ':' ScopeStatementList?
    {
        pin = 1
        //no need for processing declarations, since each case have there own scope
    }

ScopeStatementList ::=
    StatementListNoCaseNoDefault

StatementListNoCaseNoDefault ::=
    StatementNoCaseNoDefault StatementNoCaseNoDefault*

StatementNoCaseNoDefault ::=
    NonEmptyStatementNoCaseNoDefault
    | BlockStatement

FinalSwitchStatement ::=
    'final' 'switch' '(' Expression ')' ScopeStatement
    {
        pin = 2
    }

ContinueStatement ::=
    'continue' Identifier? ';'
    {
        pin = 1
    }

BreakStatement ::=
    'break' Identifier? ';'
    {
        pin = 1
    }

ReturnStatement ::=
    'return' Expression? ';'
    {
        pin = 1
    }

GotoStatement ::=
    'goto' Identifier ';'
    | 'goto' 'default' ';'
    | 'goto' 'case' ';'
    | 'goto' 'case' Expression ';'

WithStatement ::=
    WithStatementExpression
    | WithStatementSymbol
    | WithStatementTemplateInstance

private WithStatementExpression ::=
    'with' '(' Expression ')' ScopeStatement
    {
        pin = 3
    }
private WithStatementSymbol ::=
    'with' '(' Symbol ')' ScopeStatement
    {
        pin = 3
    }
private WithStatementTemplateInstance ::=
    'with' '(' TemplateInstance ')' ScopeStatement
    {
        pin = 3
    }

SynchronizedStatement ::=
    SynchronizedStatementWithExpression
    | SynchronizedStatementWithoutExpression

private SynchronizedStatementWithExpression ::=
    'synchronized' '(' Expression ')' ScopeStatement
    {
        pin = 2
    }
private SynchronizedStatementWithoutExpression ::=
    'synchronized' ScopeStatement
    {
        pin = 2
    }


TryStatement ::=
    'try' ScopeStatement Catches
    | 'try' ScopeStatement Catches FinallyStatement
    | 'try' ScopeStatement FinallyStatement

Catches ::=
     Catch Catch*//todo simplify
     | LastCatch

LastCatch ::=
    'catch' Statement
    {
        pin = 2
    }

Catch ::=
    'catch' '(' CatchParameter ')' Statement
    {
        pin = 3
        methods = [processDeclarations]
    }

CatchParameter ::=
    BasicType Identifier?//identifier should be optional, but not optional in the main d grammar
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageCatchParameterStub"
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
    }

FinallyStatement ::=
    'finally' Statement
    {
        pin = 1
    }

ThrowStatement ::=
    'throw' Expression ';'
    {
        pin= 1
    }

ScopeGuardStatement ::=
    'scope' (ScopeExit|ScopeFailure|ScopeSuccess)
    {
        pin = 1
        //this should not require a processDeclarations, since no sane persn wuld declare a variable in a scope statement. Maybe in the future there should be a warning to prevent this
    }
private ScopeExit ::=
    '(' 'exit' ')' Statement
    {
        pin = 2
    }
private ScopeFailure ::=
    '(' 'success' ')' Statement
    {
        pin = 2
    }
private ScopeSuccess ::=
    '(' 'failure' ')' Statement
    {
        pin = 2
    }
PragmaStatement ::=
    Pragma Statement{
    pin = 1
    }

MixinStatement ::=
    'mixin' '(' ( AssignExpression) ')' ';'
    {
        methods = [ getName processDeclarations] // the getTemplate method should resolve the template which is being mixed in.
        implements = ["net.masterthought.dlanguage.psi.interfaces.Mixin"]
    }

AsmStatement ::=
    'asm' FunctionAttributes? '{' AsmInstructionList? '}'{
    pin = 1
    }

AsmInstructionList ::=
   AsmInstruction ';' AsmInstructionList?

AsmInstruction ::=
    Identifier ':' AsmInstruction?
    | 'align' IntegerExpression
    | 'even'
    | 'naked'
    | 'db' Operands
    | 'ds' Operands
    | 'di' Operands
    | 'dl' Operands
    | 'df' Operands
    | 'dd' Operands
    | 'de' Operands
    | Opcode Operands?
    | Opcode Operands? AsmBrExp

Operands ::=
    Operand [',' Operands]

IntegerExpression ::=
    INTEGER_LITERAL
   |  Identifier

Register ::=
    'AL' 'AH' 'AX' 'EAX'
    | 'BL' 'BH' 'BX' 'EBX'
    | 'CL' 'CH' 'CX' 'ECX'
    | 'DL' 'DH' 'DX' 'EDX'
    | 'BP' 'EBP'
    | 'SP' 'ESP'
    | 'DI' 'EDI'
    | 'SI' 'ESI'
    | 'ES' 'CS SS DS GS FS'
    | 'CR0' 'CR2' 'CR3' 'CR4'
    | 'DR0' 'DR1' 'DR2' 'DR3' 'DR6' 'DR7'
    | 'TR3' 'TR4' 'TR5' 'TR6' 'TR7'
    | 'ST'
    | 'ST(0)' 'ST(1)' 'ST(2)' 'ST(3)' 'ST(4)' 'ST(5)' 'ST(6)' 'ST(7)'
    | 'MM0'  'MM1'  'MM2'  'MM3'  'MM4'  'MM5'  'MM6'  'MM7'
    | 'XMM0' 'XMM1' 'XMM2' 'XMM3' 'XMM4' 'XMM5' 'XMM6' 'XMM7'
    | 'AL' | 'AH' | 'AX' | 'EAX'
    | 'BL' | 'BH' | 'BX' | 'EBX'
    | 'CL' | 'CH' | 'CX' | 'ECX'
    | 'DL' | 'DH' | 'DX' | 'EDX'
    | 'BP' | 'EBP'
    | 'SP' | 'ESP'
    | 'DI' | 'EDI'
    | 'SI' | 'ESI'
    | 'ES' | 'CS SS DS GS FS'
    | 'CR0' | 'CR2' | 'CR3' | 'CR4'
    | 'DR0' | 'DR1' | 'DR2' | 'DR3' | 'DR6' | 'DR7'
    | 'TR3' | 'TR4' | 'TR5' | 'TR6' | 'TR7'
    | 'ST(0)' | 'ST(1)' | 'ST(2)' | 'ST(3)' | 'ST(4)' | 'ST(5)' | 'ST(6)' | 'ST(7)'
    | 'MM0' | 'MM1' | 'MM2' | 'MM3' | 'MM4' | 'MM5' | 'MM6' | 'MM7'
    | 'XMM0' | 'XMM1' | 'XMM2' | 'XMM3' | 'XMM4' | 'XMM5' | 'XMM6' | 'XMM7'

Register64 ::=
    'RAX'  'RBX'  'RCX'  'RDX'
    | 'BPL'  'RBP'
    | 'SPL'  'RSP'
    | 'DIL'  'RDI'
    | 'SIL'  'RSI'
    | 'R8B'  'R8W'  'R8D'  'R8'
    | 'R9B'  'R9W'  'R9D'  'R9'
    | 'R10B' 'R10W' 'R10D' 'R10'
    | 'R11B' 'R11W' 'R11D' 'R11'
    | 'R12B' 'R12W' 'R12D' 'R12'
    | 'R13B' 'R13W' 'R13D' 'R13'
    | 'R14B' 'R14W' 'R14D' 'R14'
    | 'R15B' 'R15W' 'R15D' 'R15'
    | 'XMM8' 'XMM9' 'XMM10' 'XMM11' 'XMM12' 'XMM13' 'XMM14' 'XMM15'
    | 'YMM0' 'YMM1' 'YMM2' 'YMM3' 'YMM4' 'YMM5' 'YMM6' 'YMM7'
    | 'YMM8' 'YMM9' 'YMM10' 'YMM11' 'YMM12' 'YMM13' 'YMM14' 'YMM15'

Operand ::=
    AsmExp

AsmExp ::=
  AsmLogOrExp ('?' AsmExp ':' AsmExp)?

AsmLogOrExp ::=
    AsmLogAndExp ['||' AsmLogOrExp]

AsmLogAndExp ::=
    AsmOrExp ['&&' AsmLogAndExp]

AsmOrExp ::=
    AsmXorExp ['|' AsmOrExp]

AsmXorExp ::=
    AsmAndExp [ '^' AsmXorExp ]

AsmAndExp ::=
   AsmEqualExp ['&' AsmAndExp]

AsmEqualExp ::=
  AsmRelExp [ ('==' | '!=' ) AsmEqualExp]

AsmRelExp ::=
   AsmShiftExp [ ('<' | '<=' | '>' | '>=' ) AsmRelExp]

AsmShiftExp ::=
    AsmAddExp [ ('<<' | '>>' | '>>>') AsmShiftExp ]

AsmAddExp ::=
 AsmMulExp [ ('+' | '-') AsmAddExp ]

AsmMulExp ::=
   AsmBrExp [ ('*' | '/' | '%') AsmMulExp]

AsmBrExp ::=
       AsmUnaExp? ['[' AsmExp ']']

AsmUnaExp ::=
    AsmTypePrefix AsmExp
    | 'offsetof' AsmExp
    | 'seg' AsmExp
    | '+' AsmUnaExp
    | '-' AsmUnaExp
    | '!' AsmUnaExp
    | '~' AsmUnaExp
    | AsmPrimaryExp

AsmPrimaryExp ::=
    INTEGER_LITERAL
    | StringLiteral
    | FLOAT_LITERAL
    | '__LOCAL_SIZE'
    | '$'
    | Register (':' AsmExp)?
    | Register64 (':' AsmExp)?
    | DotIdentifier
    | 'this'

DotIdentifier ::=
    Identifier ['.' DotIdentifier]

AsmTypePrefix ::=
    'near' 'ptr'
    | 'far' 'ptr'
    | 'byte' 'ptr'
    | 'short' 'ptr'
    | 'int' 'ptr'
    | 'word' 'ptr'
    | 'dword' 'ptr'
    | 'qword' 'ptr'
    | 'float' 'ptr'
    | 'double' 'ptr'
    | 'real' 'ptr'
    | 'real ptr'

Opcode ::=
 'aaa'
| 'aad'
| 'aam'
| 'aas'
| 'adc'
| 'add'
| 'addpd'
| 'addps'
| 'addsd'
| 'addss'
| 'and'
| 'andnpd'
| 'andnps'
| 'andpd'
| 'andps'
| 'arpl'
| 'bound'
| 'bsf'
| 'bsr'
| 'bswap'
| 'bt'
| 'btc'
| 'btr'
| 'bts'
| 'call'
| 'cbw'
| 'cdq'
| 'clc'
| 'cld'
| 'clflush'
| 'cli'
| 'clts'
| 'cmc'
| 'cmova'
| 'cmovae'
| 'cmovb'
| 'cmovbe'
| 'cmovc'
| 'cmove'
| 'cmovg'
| 'cmovge'
| 'cmovl'
| 'cmovle'
| 'cmovna'
| 'cmovnae'
| 'cmovnb'
| 'cmovnbe'
| 'cmovnc'
| 'cmovne'
| 'cmovng'
| 'cmovnge'
| 'cmovnl'
| 'cmovnle'
| 'cmovno'
| 'cmovnp'
| 'cmovns'
| 'cmovnz'
| 'cmovo'
| 'cmovp'
| 'cmovpe'
| 'cmovpo'
| 'cmovs'
| 'cmovz'
| 'cmp'
| 'cmppd'
| 'cmpps'
| 'cmps'
| 'cmpsb'
| 'cmpsd'
| 'cmpss'
| 'cmpsw'
| 'cmpxchg'
| 'cmpxchg8b'
| 'cmpxchg16b'
| 'comisd'
| 'comiss'
| 'cpuid'
| 'cvtdq2pd'
| 'cvtdq2ps'
| 'cvtpd2dq'
| 'cvtpd2pi'
| 'cvtpd2ps'
| 'cvtpi2pd'
| 'cvtpi2ps'
| 'cvtps2dq'
| 'cvtps2pd'
| 'cvtps2pi'
| 'cvtsd2si'
| 'cvtsd2ss'
| 'cvtsi2sd'
| 'cvtsi2ss'
| 'cvtss2sd'
| 'cvtss2si'
| 'cvttpd2dq'
| 'cvttpd2pi'
| 'cvttps2dq'
| 'cvttps2pi'
| 'cvttsd2si'
| 'cvttss2si'
| 'cwd'
| 'cwde'
| 'da'
| 'daa'
| 'das'
| 'db'
| 'dd'
| 'de'
| 'dec'
| 'df'
| 'di'
| 'div'
| 'divpd'
| 'divps'
| 'divsd'
| 'divss'
| 'dl'
| 'dq'
| 'ds'
| 'dt'
| 'dw'
| 'emms'
| 'enter'
| 'f2xm1'
| 'fabs'
| 'fadd'
| 'faddp'
| 'fbld'
| 'fbstp'
| 'fchs'
| 'fclex'
| 'fcmovb'
| 'fcmovbe'
| 'fcmove'
| 'fcmovnb'
| 'fcmovnbe'
| 'fcmovne'
| 'fcmovnu'
| 'fcmovu'
| 'fcom'
| 'fcomi'
| 'fcomip'
| 'fcomp'
| 'fcompp'
| 'fcos'
| 'fdecstp'
| 'fdisi'
| 'fdiv'
| 'fdivp'
| 'fdivr'
| 'fdivrp'
| 'feni'
| 'ffree'
| 'fiadd'
| 'ficom'
| 'ficomp'
| 'fidiv'
| 'fidivr'
| 'fild'
| 'fimul'
| 'fincstp'
| 'finit'
| 'fist'
| 'fistp'
| 'fisub'
| 'fisubr'
| 'fld'
| 'fld1'
| 'fldcw'
| 'fldenv'
| 'fldl2e'
| 'fldl2t'
| 'fldlg2'
| 'fldln2'
| 'fldpi'
| 'fldz'
| 'fmul'
| 'fmulp'
| 'fnclex'
| 'fndisi'
| 'fneni'
| 'fninit'
| 'fnop'
| 'fnsave'
| 'fnstcw'
| 'fnstenv'
| 'fnstsw'
| 'fpatan'
| 'fprem'
| 'fprem1'
| 'fptan'
| 'frndint'
| 'frstor'
| 'fsave'
| 'fscale'
| 'fsetpm'
| 'fsin'
| 'fsincos'
| 'fsqrt'
| 'fst'
| 'fstcw'
| 'fstenv'
| 'fstp'
| 'fstsw'
| 'fsub'
| 'fsubp'
| 'fsubr'
| 'fsubrp'
| 'ftst'
| 'fucom'
| 'fucomi'
| 'fucomip'
| 'fucomp'
| 'fucompp'
| 'fwait'
| 'fxam'
| 'fxch'
| 'fxrstor'
| 'fxsave'
| 'fxtract'
| 'fyl2x'
| 'fyl2xp1'
| 'hlt'
| 'idiv'
| 'imul'
| 'in'
| 'inc'
| 'ins'
| 'insb'
| 'insd'
| 'insw'
| 'int'
| 'into'
| 'invd'
| 'invlpg'
| 'iret'
| 'iretd'
| 'ja'
| 'jae'
| 'jb'
| 'jbe'
| 'jc'
| 'jcxz'
| 'je'
| 'jecxz'
| 'jg'
| 'jge'
| 'jl'
| 'jle'
| 'jmp'
| 'jna'
| 'jnae'
| 'jnb'
| 'jnbe'
| 'jnc'
| 'jne'
| 'jng'
| 'jnge'
| 'jnl'
| 'jnle'
| 'jno'
| 'jnp'
| 'jns'
| 'jnz'
| 'jo'
| 'jp'
| 'jpe'
| 'jpo'
| 'js'
| 'jz'
| 'lahf'
| 'lar'
| 'ldmxcsr'
| 'lds'
| 'lea'
| 'leave'
| 'les'
| 'lfence'
| 'lfs'
| 'lgdt'
| 'lgs'
| 'lidt'
| 'lldt'
| 'lmsw'
| 'lock'
| 'lods'
| 'lodsb'
| 'lodsd'
| 'lodsw'
| 'loop'
| 'loope'
| 'loopne'
| 'loopnz'
| 'loopz'
| 'lsl'
| 'lss'
| 'ltr'
| 'maskmovdqu'
| 'maskmovq'
| 'maxpd'
| 'maxps'
| 'maxsd'
| 'maxss'
| 'mfence'
| 'minpd'
| 'minps'
| 'minsd'
| 'minss'
| 'mov'
| 'movapd'
| 'movaps'
| 'movd'
| 'movdq2q'
| 'movdqa'
| 'movdqu'
| 'movhlps'
| 'movhpd'
| 'movhps'
| 'movlhps'
| 'movlpd'
| 'movlps'
| 'movmskpd'
| 'movmskps'
| 'movntdq'
| 'movnti'
| 'movntpd'
| 'movntps'
| 'movntq'
| 'movq'
| 'movq2dq'
| 'movs'
| 'movsb'
| 'movsd'
| 'movss'
| 'movsw'
| 'movsx'
| 'movupd'
| 'movups'
| 'movzx'
| 'mul'
| 'mulpd'
| 'mulps'
| 'mulsd'
| 'mulss'
| 'neg'
| 'nop'
| 'not'
| 'or'
| 'orpd'
| 'orps'
| 'out'
| 'outs'
| 'outsb'
| 'outsd'
| 'outsw'
| 'packssdw'
| 'packsswb'
| 'packuswb'
| 'paddb'
| 'paddd'
| 'paddq'
| 'paddsb'
| 'paddsw'
| 'paddusb'
| 'paddusw'
| 'paddw'
| 'pand'
| 'pandn'
| 'pavgb'
| 'pavgw'
| 'pcmpeqb'
| 'pcmpeqd'
| 'pcmpeqw'
| 'pcmpgtb'
| 'pcmpgtd'
| 'pcmpgtw'
| 'pextrw'
| 'pinsrw'
| 'pmaddwd'
| 'pmaxsw'
| 'pmaxub'
| 'pminsw'
| 'pminub'
| 'pmovmskb'
| 'pmulhuw'
| 'pmulhw'
| 'pmullw'
| 'pmuludq'
| 'pop'
| 'popa'
| 'popad'
| 'popf'
| 'popfd'
| 'por'
| 'prefetchnta'
| 'prefetcht0'
| 'prefetcht1'
| 'prefetcht2'
| 'psadbw'
| 'pshufd'
| 'pshufhw'
| 'pshuflw'
| 'pshufw'
| 'pslld'
| 'pslldq'
| 'psllq'
| 'psllw'
| 'psrad'
| 'psraw'
| 'psrld'
| 'psrldq'
| 'psrlq'
| 'psrlw'
| 'psubb'
| 'psubd'
| 'psubq'
| 'psubsb'
| 'psubsw'
| 'psubusb'
| 'psubusw'
| 'psubw'
| 'punpckhbw'
| 'punpckhdq'
| 'punpckhqdq'
| 'punpckhwd'
| 'punpcklbw'
| 'punpckldq'
| 'punpcklqdq'
| 'punpcklwd'
| 'push'
| 'pusha'
| 'pushad'
| 'pushf'
| 'pushfd'
| 'pxor'
| 'rcl'
| 'rcpps'
| 'rcpss'
| 'rcr'
| 'rdmsr'
| 'rdpmc'
| 'rdtsc'
| 'rep'
| 'repe'
| 'repne'
| 'repnz'
| 'repz'
| 'ret'
| 'retf'
| 'rol'
| 'ror'
| 'rsm'
| 'rsqrtps'
| 'rsqrtss'
| 'sahf'
| 'sal'
| 'sar'
| 'sbb'
| 'scas'
| 'scasb'
| 'scasd'
| 'scasw'
| 'seta'
| 'setae'
| 'setb'
| 'setbe'
| 'setc'
| 'sete'
| 'setg'
| 'setge'
| 'setl'
| 'setle'
| 'setna'
| 'setnae'
| 'setnb'
| 'setnbe'
| 'setnc'
| 'setne'
| 'setng'
| 'setnge'
| 'setnl'
| 'setnle'
| 'setno'
| 'setnp'
| 'setns'
| 'setnz'
| 'seto'
| 'setp'
| 'setpe'
| 'setpo'
| 'sets'
| 'setz'
| 'sfence'
| 'sgdt'
| 'shl'
| 'shld'
| 'shr'
| 'shrd'
| 'shufpd'
| 'shufps'
| 'sidt'
| 'sldt'
| 'smsw'
| 'sqrtpd'
| 'sqrtps'
| 'sqrtsd'
| 'sqrtss'
| 'stc'
| 'std'
| 'sti'
| 'stmxcsr'
| 'stos'
| 'stosb'
| 'stosd'
| 'stosw'
| 'str'
| 'sub'
| 'subpd'
| 'subps'
| 'subsd'
| 'subss'
| 'sysenter'
| 'sysexit'
| 'test'
| 'ucomisd'
| 'ucomiss'
| 'ud2'
| 'unpckhpd'
| 'unpckhps'
| 'unpcklpd'
| 'unpcklps'
| 'verr'
| 'verw'
| 'wait'
| 'wbinvd'
| 'wrmsr'
| 'xadd'
| 'xchg'
| 'xlat'
| 'xlatb'
| 'xor'
| 'xorpd'
| 'xorps'
| 'addsubpd'
| 'addsubps'
| 'fisttp'
| 'haddpd'
| 'haddps'
| 'hsubpd'
| 'hsubps'
| 'lddqu'
| 'monitor'
| 'movddup'
| 'movshdup'
| 'movsldup'
| 'mwait'
| 'pavgusb'
| 'pf2id'
| 'pfacc'
| 'pfadd'
| 'pfcmpeq'
| 'pfcmpge'
| 'pfcmpgt'
| 'pfmax'
| 'pfmin'
| 'pfmul'
| 'pfnacc'
| 'pfpnacc'
| 'pfrcp'
| 'pfrcpit1'
| 'pfrcpit2'
| 'pfrsqit1'
| 'pfrsqrt'
| 'pfsub'
| 'pfsubr'
| 'pi2fd'
| 'pmulhrw'
| 'pswapd'

Declaration ::=
   VarFuncDeclaration
   | FuncDeclaration
   | EnumDeclaration
   | VarDeclarations //must come before alias decleration
   | AliasDeclaration
   | AggregateDeclaration
   | ImportDeclaration
   | TemplateDeclaration

VarFuncDeclaration ::=
    (('enum'|'auto'|Type) FuncDeclarator '=' AssignExpression ';')
    | (('enum'|'auto'|Type) BasicType FuncDeclarator '=' AssignExpression ';')
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility actuallyIsDeclaration getDeclarationType processDeclarations]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageVarFuncDeclarationStub"
        implements=["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration" ]
    }


AliasDeclaration ::=
  AliasDeclarationSingle
  | 'alias' AliasDeclarationX ';'

AliasDeclarationSingle ::=
    'alias' Identifier '=' Type TemplateArguments? ';'
    | 'alias' Identifier '=' Initializer ';'
    | 'alias' StorageClasses? BasicType (FuncDeclarator|Declarator) ';'
    {
         methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility actuallyIsDeclaration getDeclarationType processDeclarations]
         stubClass="net.masterthought.dlanguage.stubs.DLanguageAliasDeclarationSingleStub"
         implements=["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
    }

//todo make the alias declaration rule non recursive
AliasDeclarationX ::=
    AliasDeclarationY [',' AliasDeclarationX]

AliasDeclarationY ::=
    Identifier TemplateParameters? '=' ( StorageClasses? Type | FunctionLiteral)
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility actuallyIsDeclaration getDeclarationType processDeclarations]
                 stubClass="net.masterthought.dlanguage.stubs.DLanguageAliasDeclarationYStub"
                 implements=["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
    }

AutoDeclaration ::=
    StorageClasses? AutoDeclarationX ';'

AutoDeclarationX ::=
    AutoDeclarationY [',' AutoDeclarationX]

AutoDeclarationY ::=
    Identifier TemplateParameters? '=' Initializer
    {
        methods = [getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility actuallyIsDeclaration getVariableDeclarationType processDeclarations]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageAutoDeclarationStub"
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration" "net.masterthought.dlanguage.psi.interfaces.Declaration" ]
    }

VarDeclarations ::=
    StorageClasses BasicType Declarators ';'
    | StorageClasses? BasicType? Declarators ';'
    | AutoDeclaration

Declarators ::=
    DeclaratorInitializer (',' DeclaratorIdentifierList)?

DeclaratorInitializer ::=
    AltDeclarator ('=' Initializer)?
    | VarDeclarator (TemplateParameters? '=' Initializer)?
    {
        methods=[ getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility actuallyIsDeclaration getVariableDeclarationType processDeclarations]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageDeclaratorInitializerStub"
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration" "net.masterthought.dlanguage.psi.interfaces.Declaration" ]
    }


DeclaratorIdentifierList ::=
    DeclaratorIdentifier [',' DeclaratorIdentifierList]

DeclaratorIdentifier ::=
    VarDeclaratorIdentifier
    | AltDeclaratorIdentifier

VarDeclaratorIdentifier ::=
    Identifier TemplateParameters? '=' Initializer//needs to be named element

AltDeclaratorIdentifier ::=
    BasicType2? Identifier AltDeclaratorSuffixes? ('=' Initializer)?//needs to be named element

Declarator ::=
    VarDeclarator
    | AltDeclarator

VarDeclarator ::=
    BasicType2? Identifier

AltDeclarator ::=
    BasicType2? Identifier AltDeclaratorSuffixes
    | BasicType2? '(' AltDeclaratorX ')' AltFuncDeclaratorSuffix? AltDeclaratorSuffixes?

AltDeclaratorX ::=
    BasicType2? Identifier AltFuncDeclaratorSuffix?
    | AltDeclarator

AltDeclaratorSuffixes ::=
    AltDeclaratorSuffix AltDeclaratorSuffix*

AltDeclaratorSuffix ::=
    '[' (AssignExpression | Type)? ']'

AltFuncDeclaratorSuffix ::=
    Parameters MemberFunctionAttributes?

StorageClasses ::=
    StorageClass StorageClass*

StorageClass ::=
    LinkageAttribute
    | AlignAttribute
    | 'deprecated'
    | 'enum'
    | 'static'
    | 'extern'
    | 'abstract'
    | 'final'
    | 'override'
    | 'synchronized'
    | 'auto'
    | 'scope'
    | 'const'
    | 'immutable'
    | 'inout'
    | 'shared'
    | '__gshared'
    | Property
    | 'nothrow'
    | 'pure'
    | 'ref'

Initializer ::=
    VoidInitializer
    | NonVoidInitializer

VoidInitializer ::=
    'void'

NonVoidInitializer ::=
    AssignExpression
    | ArrayInitializer
    | StructInitializer

ArrayInitializer ::=
    '[' ArrayMemberInitializations? ','? ']'


ArrayMemberInitializations ::=
    ArrayMemberInitialization (',' ArrayMemberInitialization)*

ArrayMemberInitialization ::=
    NonVoidInitializer [':' NonVoidInitializer]

StructInitializer ::=
    '{' StructMemberInitializers? ','? '}'//extra comma necessary for extra comas which are allowed by dlang

StructMemberInitializers ::=
    StructMemberInitializer (',' StructMemberInitializer)*

StructMemberInitializer ::=
 NonVoidInitializer [':' NonVoidInitializer]

//Function

FuncDeclaration ::=
    StorageClasses? BasicType FuncDeclarator (FunctionBody |';' )?
    | AutoFuncDeclaration
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation getParameterList isSomeVisibility getTemplateArguments getProtection getParameterList isSystem isNoGC isTrusted hasCustomProperty isSafe getCustomProperty isPropertyFunction processDeclarations]
        implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasProperty" "net.masterthought.dlanguage.psi.interfaces.HasTemplateParameters" "net.masterthought.dlanguage.psi.interfaces.HasParameters" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageFuncDeclarationStub"
    }

private AutoFuncDeclaration ::=
    StorageClasses Identifier FuncDeclaratorSuffix FunctionBody?

private FuncDeclarator ::=
    BasicType2? Identifier FuncDeclaratorSuffix

private FuncDeclaratorSuffix ::=
     TemplateParameters? Parameters MemberFunctionAttributes? Constraint?
     | Parameters MemberFunctionAttributes?

Parameters ::=
    '(' ParameterList? ')'{
        methods = [ processDeclarations ]
    }

ParameterList ::=
    Parameter (',' Parameter)* ','? '...'?
    | '...'{
    methods = [ processDeclarations ]
    }

Parameter ::=
       InOut? BasicType Declarator (('...' | '=') AssignExpression?)?
       | InOut? Type '=' AssignExpression
       | InOut? 'alias' Identifier '=' AssignExpression
       | InOut? Type ('...')?//why is this '...'? necesary. surely Parameterlist covers this
       {
            methods = [getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility ]
            implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.Declaration" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration"]
            stubClass="net.masterthought.dlanguage.stubs.DLanguageParameterStub"
       }


InOut ::=
    InOutX InOutX*

InOutX ::=
    'auto'
    | TypeCtor
    | 'final'
    | 'in'
    | 'lazy'
    | 'out'
    | 'ref'
    | 'scope'
    | ('return' 'ref')
    | 'return' //added becuase off: "char[] toUTF8(return out char[4] buf, dchar c) nothrow @nogc @safe pure"

FunctionAttributes ::=
    FunctionAttribute FunctionAttribute*

FunctionAttribute ::=
    'nothrow'
    | 'pure'
    | Property

MemberFunctionAttributes ::=
  MemberFunctionAttribute MemberFunctionAttribute*

MemberFunctionAttribute ::=
    'const'
    | 'immutable'
    | 'inout'
    | 'shared'
    | 'return'
    | FunctionAttribute

FunctionBody ::=
    BlockStatement
   | FunctionContracts? BodyStatement


FunctionContracts ::=
    InStatement OutStatement?
    | OutStatement InStatement?

InStatement ::=
    'in' BlockStatement
    {
        pin = 2
    }

OutStatement ::=
    'out' BlockStatement
    | 'out' '(' Identifier ')' BlockStatement
    {

    }

BodyStatement ::=
    'body' BlockStatement
    {
        pin = 1
    }

Constructor ::=
    'this' Parameters MemberFunctionAttributes? ';'
    | 'this' Parameters MemberFunctionAttributes? FunctionBody
    | ConstructorTemplate
    {
         methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility getParameterList processDeclarations]
         implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateParameters" "net.masterthought.dlanguage.psi.interfaces.HasParameters" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
         stubClass="net.masterthought.dlanguage.stubs.DLanguageConstructorStub"
    }

private ConstructorTemplate ::=
    'this' TemplateParameters Parameters MemberFunctionAttributes? Constraint? ';'
    | 'this' TemplateParameters Parameters MemberFunctionAttributes? Constraint? FunctionBody

Destructor ::=
    '~' 'this' '(' ')' MemberFunctionAttributes? ';'
    | '~' 'this' '(' ')' MemberFunctionAttributes? FunctionBody
    {
        implements = ["net.masterthought.dlanguage.psi.interfaces.DCompositeElement"]
        extends = "net.masterthought.dlanguage.psi.impl.DStubbedPsiElementBase<net.masterthought.dlanguage.stubs.DLanguageDestructorStub>"
        stubClass="net.masterthought.dlanguage.stubs.DLanguageDestructorStub"
    }

Postblit ::=
    'this' '(' 'this' ')' MemberFunctionAttributes? ';'
    | 'this' '(' 'this' ')' MemberFunctionAttributes? FunctionBody

Allocator ::=
    'new' Parameters ';'
    | 'new' Parameters FunctionBody

Deallocator ::=
    'delete' Parameters ';'
    | 'delete' Parameters FunctionBody

Invariant ::=
    InvariantWithParen
    | InvariantWithoutParen

private InvariantWithoutParen ::=
    'invariant' BlockStatement
    {
        pin = 2
    }

private InvariantWithParen ::=
    'invariant' '(' ')' BlockStatement
    {
        pin = 2
    }

UnitTesting ::=
    'unittest' BlockStatement
    {
        pin= 1
        implements = ["net.masterthought.dlanguage.psi.interfaces.DCompositeElement"]
        extends = "net.masterthought.dlanguage.psi.impl.DStubbedPsiElementBase<net.masterthought.dlanguage.stubs.interfaces.UnitTestingStub>"
        stubClass="net.masterthought.dlanguage.stubs.interfaces.UnitTestingStub"
    }

StaticConstructor ::=
    'static' 'this' '(' ')' ';'
    | 'static' 'this' '(' ')' FunctionBody
    {
       implements = ["net.masterthought.dlanguage.psi.interfaces.DCompositeElement"]
       extends = "net.masterthought.dlanguage.psi.impl.DStubbedPsiElementBase<net.masterthought.dlanguage.stubs.DLanguageStaticConstructorStub>"
       stubClass="net.masterthought.dlanguage.stubs.DLanguageStaticConstructorStub"
   }

StaticDestructor ::=
    'static' '~' 'this' '(' ')' MemberFunctionAttributes? ';'
    | 'static' '~' 'this' '(' ')' MemberFunctionAttributes? FunctionBody
    {
        implements = ["net.masterthought.dlanguage.psi.interfaces.DCompositeElement"]
        extends = "net.masterthought.dlanguage.psi.impl.DStubbedPsiElementBase<net.masterthought.dlanguage.stubs.DLanguageStaticDestructorStub>"
        stubClass="net.masterthought.dlanguage.stubs.DLanguageStaticDestructorStub"
    }

SharedStaticConstructor ::=
    'shared' 'static' 'this' '(' ')' ';'
    | 'shared' 'static' 'this' '(' ')' FunctionBody
    {
        implements = ["net.masterthought.dlanguage.psi.interfaces.DCompositeElement"]
        extends = "net.masterthought.dlanguage.psi.impl.DStubbedPsiElementBase<net.masterthought.dlanguage.stubs.DLanguageSharedStaticConstructorStub>"
        stubClass="net.masterthought.dlanguage.stubs.DLanguageSharedStaticConstructorStub"
    }

SharedStaticDestructor ::=
    'shared' 'static' '~' 'this' '(' ')' MemberFunctionAttributes? ';'
    | 'shared' 'static' '~' 'this' '(' ')' MemberFunctionAttributes? FunctionBody
    {
        implements = ["net.masterthought.dlanguage.psi.interfaces.DCompositeElement"]
        extends = "net.masterthought.dlanguage.psi.impl.DStubbedPsiElementBase<net.masterthought.dlanguage.stubs.DLanguageSharedStaticDestructorStub>"
        stubClass="net.masterthought.dlanguage.stubs.DLanguageSharedStaticDestructorStub"
    }

// Aggregate

AggregateDeclaration ::=
    ClassDeclaration
    | InterfaceDeclaration
    | StructDeclaration
    | UnionDeclaration

ClassDeclaration ::=
    'class' Identifier ';'
    | 'class' Identifier BaseClassList? AggregateBody
    | ClassTemplateDeclaration
    {
       methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility getProtection whatInheritsFrom getSuperClassNames processDeclarations]
       implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateParameters" "net.masterthought.dlanguage.psi.interfaces.CanInherit" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
       stubClass="net.masterthought.dlanguage.stubs.DLanguageClassDeclarationStub"
    }

private ClassTemplateDeclaration ::=
    'class' Identifier TemplateParameters Constraint? BaseClassList? AggregateBody
    | 'class' Identifier TemplateParameters BaseClassList Constraint AggregateBody

InterfaceDeclaration ::=
    'interface' Identifier ';'
    | InterfaceTemplateDeclaration
    | 'interface' Identifier BaseInterfaceList? AggregateBody?
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility whatInheritsFrom getTemplateArguments getSuperClassNames]
        implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.CanInherit" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageInterfaceDeclarationStub"
    }


private InterfaceTemplateDeclaration ::=
    'interface' Identifier TemplateParameters Constraint? BaseInterfaceList? AggregateBody

StructDeclaration ::=
    'struct' Identifier? TemplateParameters? Constraint? (AggregateBody | ';')?
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility getTemplateArguments processDeclarations]
        implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateParameters" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageStructDeclarationStub"
   }

UnionDeclaration ::=
    'union' Identifier ';'
    | 'union' Identifier AggregateBody
    | UnionTemplateDeclaration
    | AnonUnionDeclaration
    {
        methods = [getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility getTemplateArguments processDeclarations]
        implements = ["net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateParameters" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
         stubClass="net.masterthought.dlanguage.stubs.DLanguageUnionDeclarationStub"
    }

private UnionTemplateDeclaration ::=
    'union' Identifier TemplateParameters Constraint? AggregateBody
    {
        pin = 2// pin must be 2 because anon declarations have no identifier
    }

private AnonUnionDeclaration ::=
    'union' AggregateBody
    {
        pin = 1
    }

AggregateBody ::=
    '{' DeclDefs? '}'

BaseClassList ::=
    ':' SuperClass (',' Interfaces)?
    | ':' Interfaces

BaseInterfaceList ::=
    ':' Interfaces

SuperClass ::=
    BasicType

Interfaces ::=
    Interface (',' Interface)*

Interface ::=
    BasicType

AliasThis ::=
    'alias' Identifier 'this' ';'
    {
        pin  = 3
    }

// Enum

//EnumBody ::=
//     '{' EnumMember (',' EnumMember?)* '}'
//
// AnonymousEnumMember ::=
//       Type? Identifier ('=' AssignExpression)?
//
// AnonymousEnumDeclaration ::=
//     'enum' (':' Type)? '{' AnonymousEnumMember? '}'
//
// EnumDeclaration ::=
//       'enum' Identifier (':' Type)? EnumBody? ';'
//     | AnonymousEnumDeclaration
//
//
// EnumMember ::=
//      Identifier? '=' AssignExpression

EnumDeclaration ::=
    'enum' Identifier (':' EnumBaseType)? EnumBody
    | AnonymousEnumDeclaration{
      methods = [getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
      implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
       stubClass="net.masterthought.dlanguage.stubs.DLanguageEnumDeclarationStub"
  }

EnumBaseType ::=
    Type

EnumBody ::=
    '{' EnumMembers ','? '}'

EnumMembers ::=
    EnumMember (',' EnumMember)*{
        methods = [processDeclarations]
    }

EnumMember ::= Identifier ('=' AssignExpression)? | Type Identifier '=' AssignExpression
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility]
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageEnumMemberStub"
    }

AnonymousEnumDeclaration ::=
    'enum' (':' EnumBaseType)? ('{' EnumMembers ','? '}')?//',' needed for extra comma allowed by d
//todo: sometimes declarations like "enum foo;" will be parsed as an anonymous enum declaration + an identifier. This means that the {EnumMembers ','?}, needs to be optional. This could be fixed

//Template

TemplateDeclaration ::=
    'template' Identifier TemplateParameters Constraint? '{' DeclDefs? '}'
    {
        pin= 2
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation getTemplateArguments isSomeVisibility processDeclarations]
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.containers.GlobalDeclarationContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateParameters" "net.masterthought.dlanguage.psi.interfaces.Mixinable" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageTemplateDeclarationStub"
    }

TemplateParameters ::=
    '(' TemplateParameterList? ','? ')'

TemplateParameterList ::=
    TemplateParameter (',' TemplateParameter)*

Constraint ::=
    'if' '(' Expression ')'
    {
        pin = 1
    }

TemplateInstance ::=
    Identifier? TemplateArguments//todo that identifier should not be optional


/******************************************
     * Parse template arguments.
     * Input:
     *      current token is opening '!'
     * Output:
     *      current token is one after closing '$(RPAREN)'
     * Comment taken from dmd source
     * todo dmd source has an equivalent to a recover rule for this
     */
TemplateArguments ::=
     TemplateArgumentsWithParen
     | TemplateArgumentsWithoutParen

private TemplateArgumentsWithParen ::=
    '!' '(' TemplateArgumentList? ')'
    {
        pin = 2
    }
private TemplateArgumentsWithoutParen ::=
    '!' TemplateSingleArgument
    {
        pin = 1
    }


/******************************************
     * Parse template argument list.
     * Input:
     *      current token is opening '$(LPAREN)',
     *          or ',' for __traits
     * Output:
     *      current token is one after closing '$(RPAREN)'
     * comment taken from dmd source todo add this to the top of the file so I don't have to write this every time
     * this differes from  the dmd source by not having '(' and ')' included in the tenplate argument list. This is so that there can be better pins.
     */
TemplateArgumentList ::=
    TemplateArgument (',' TemplateArgument)* ','?

/**
 *   template argument rule not included in dmd source
 * old version:
//TemplateArgument ::=
//    Lambda //must be above assign expression
//    | AssignExpression
//    | Type //this branch should be deprecated  since anything matched by Type is in theory matched by assignexpression
//    | Symbol
 *
 */

TemplateArgument ::=
    Type
    | AssignExpression

Symbol ::=
    ('.')? SymbolTail

SymbolTail ::=
    (Identifier | TemplateInstance) ('.' (Identifier | TemplateInstance))*

/*****************************
 * Parse single template argument, to support the syntax:
 *      foo!arg
 * Input:
 *      current token is the arg
 * todo the dmd source distinguishs between type identifier and regular identifier
*/
TemplateSingleArgument ::=
    IdentifierList
    | TypeVector
    | BasicTypeX
    | PrimaryExpression

TemplateParameter ::=
    TemplateValueParameter
    | TemplateTypeParameter
    | TemplateAliasParameter
    | TemplateTupleParameter
    | TemplateThisParameter
    {
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation getTemplateArguments isSomeVisibility ]
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.Declaration" "net.masterthought.dlanguage.psi.interfaces.VariableDeclaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageTemplateParameterStub"
    }


TemplateTupleParameter ::=
    Identifier '...'

TemplateValueParameter ::=
    Identifier (
    ':' ConditionalExpression
    | '=' ConditionalExpression
    )?
//TemplateValueParameter ::=
//       BasicType Declarator ('=' (AssignExpression | SpecialKeyword))
//       | BasicType Declarator TemplateValueParameterSpecialization TemplateValueParameterDefault?

//private TemplateValueParameterSpecialization ::= ConditionalExpression

TemplateTypeParameter ::=
    Identifier (':' Type)? ( '=' Type)?

//TemplateTypeParameter ::=
//    Type Identifier? '...'? (':' Type)? ('=' Type)? (':' AssignExpression)? TemplateValueParameterDefault?

TemplateAliasParameter ::=
    'alias' (
    Type (':' (Type | ConditionalExpression))? ('=' (Type | ConditionalExpression))?
    | Identifier (':' (Type | ConditionalExpression))? ('=' (Type | ConditionalExpression))?
    ){
        pin = 1
    }
//TemplateAliasParameter ::=
//     'alias' Identifier '=' AssignExpression
//     | 'alias' Type? Identifier? (':' (Type | AssignExpression))? ('=' (Type | AssignExpression))?

TemplateThisParameter ::=
    'this' TemplateTypeParameter {
        pin = 1
    }

//TemplateValueParameterDefault ::=
//    '=' ( AssignExpression | SpecialKeyword)

TemplateMixinDeclaration ::=
    'mixin' 'template' Identifier TemplateParameters Constraint? '{' DeclDefs? '}'
    {
        pin = 3
        methods=[getName getFullName getNameIdentifier getReference setName getPresentation isSomeVisibility processDeclarations]
        implements = ["net.masterthought.dlanguage.psi.interfaces.DNamedElement" "net.masterthought.dlanguage.psi.interfaces.containers.StatementContainer" "net.masterthought.dlanguage.psi.interfaces.containers.MixinContainer" "net.masterthought.dlanguage.psi.interfaces.containers.GlobalDeclarationContainer" "net.masterthought.dlanguage.psi.interfaces.HasVisibility" "net.masterthought.dlanguage.psi.interfaces.HasTemplateParameters" "net.masterthought.dlanguage.psi.interfaces.Mixinable" "net.masterthought.dlanguage.psi.interfaces.Declaration"]
        stubClass="net.masterthought.dlanguage.stubs.DLanguageTemplateMixinDeclarationStub"
    }

/******************************************
     * Parse template mixin.
     *      mixin Foo;
     *      mixin Foo!(args);
     *      mixin a.b.c!(args).Foo!(args);
     *      mixin Foo!(args) identifier;
     *      mixin typeof(expr).identifier!(args);
     * Comment from dmd source




     */
TemplateMixin ::=
    'mixin' MixinTemplateName TemplateArguments? Identifier? ';'
    {
        methods = [ getName processDeclarations ]
        implements = ["net.masterthought.dlanguage.psi.interfaces.Mixin"]
    }

MixinTemplateName ::=
    Typeof? '.'? QualifiedIdentifierList

QualifiedIdentifierList ::=
    (Identifier | TemplateInstance) ( '.' (Identifier | TemplateInstance) )*

//Attribute
AttributeSpecifier ::=
    Attribute (':' | DeclarationBlock)

Attribute ::=
    LinkageAttribute
    | AlignAttribute
    | DeprecatedAttribute
    | ProtectionAttribute
    | Pragma
    | 'static'
    | 'extern'
    | 'abstract'
    | 'final'
    | 'override'
    | 'synchronized'
    | 'auto'
    | 'scope'
    | 'const'
    | 'immutable'
    | 'inout'
    | 'shared'
    | '__gshared'
    | Property
    | 'nothrow'
    | 'pure'
    | 'ref'

DeclarationBlock ::=
    DeclDef
    | '{' DeclDefs? '}'
    {
    }

LinkageAttribute ::=
    'extern' '(' LinkageType ')'
    | 'extern' '(' Identifier '++' (',' IdentifierList)? ')'

LinkageType ::=
     'C'
    | Identifier '++'
    | 'D'
    | 'Windows'
    | 'Pascal'
    | 'System'
    | 'Objective-C'

AlignAttribute ::=
    'align' ('(' INTEGER_LITERAL ')')?
    {
        pin = 1
    }

DeprecatedAttribute ::=
    'deprecated' ('(' AssignExpression')')?
    {
        pin = 1
    }

ProtectionAttribute ::=
     'private'
    | 'package' '(' IdentifierList ')'
    | 'package'
    | 'protected'
    | 'public'
    | 'export'

Property ::=
    BuiltInProperty
    | UserDefinedAttribute

private BuiltInProperty ::=
    '@' PropertyIdentifier

PropertyIdentifier ::=
     'property'
    | 'safe'
    | 'trusted'
    | 'system'
    | 'disable'
    | 'nogc'

UserDefinedAttribute ::=
    UserDefinedAttributeArgumentOnly
    | UserDefinedAttributeWithTemplateInstance //must be above with identifier, becuae the pin on with Identifier will falsely match templates todo
    | UserDefinedAttributeWithIdentifier

private UserDefinedAttributeArgumentOnly ::=
    '@' '(' ArgumentList ')'
    {
        pin = 2
    }

private UserDefinedAttributeWithIdentifier ::=
    '@' Identifier ('(' ArgumentList? ')')?

private UserDefinedAttributeWithTemplateInstance ::=
    '@' TemplateInstance ('(' ArgumentList? ')')?

Pragma ::=
    'pragma' '(' Identifier (',' ArgumentList)? ')'
    {
        pin = 1
    }

//Conditional

ConditionalDeclaration ::=
    Condition DeclarationBlock 'else' ':' DeclDefs?//must be on top
    | Condition DeclarationBlock ('else' DeclarationBlock)?
    | Condition ':' DeclDefs?

ConditionalStatement ::=
    Condition (Statement | BlockStatement | DeclarationBlock) ('else' (Statement | DeclarationBlock))?
    {
        methods = [processDeclarations]
    }

Condition ::=
    VersionCondition
    | DebugCondition
    | StaticIfCondition

VersionCondition ::=
    'version' '(' (INTEGER_LITERAL | Identifier | 'unittest' | 'assert') ')'
    {
        pin = 2
    }

DebugCondition ::=
    'debug' ('(' (INTEGER_LITERAL | Identifier) ')')?
    {
        pin = 1
    }

StaticIfCondition ::=
    'static' 'if' '(' AssignExpression ')' /*(DeclDef | AggregateBody)? StaticElseCondition?*/
    {
        pin = 3
    }

//todo refactor Conditional declaration so that static else condition is not necesaray
StaticElseCondition ::=
    ('else' DeclarationBlock)
    {
        pin = 1
    }

VersionSpecification ::=
    'version' '=' (Identifier | INTEGER_LITERAL) ';'
    {
        pin = 2
    }

DebugSpecification ::=
   'debug' '=' (Identifier | INTEGER_LITERAL) ';'
   {
       pin = 2
   }

StaticAssert ::=
    'static' 'assert' '(' AssignExpression (',' AssignExpression)? ')' ';'
    {
        pin = 3
    }

