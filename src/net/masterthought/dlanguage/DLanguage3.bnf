{

  tokens=[
  
   Assign = "="
    At =  "@"
    BitAnd =  "&"
    BitAndEqual =  "&="
    BitOr =  "|"
    BitOrEqual =  "|="
    CatEqual =  "~="
    Colon =  ":"
    Comma =  ","
    Decrement =  "--"
    Div =  "/"
    DivEqual =  "/="
    Dollar =  "$"
    Dot =  "."
    Equal =  "=="
    GoesTo =  "=>"
    Greater =  ">"
    GreaterEqual =  ">="
    Hash =  "#"
    Increment =  "++"
    LBrace =  "{"
    LBracket =  "["
    Less =  "<"
    LessEqual =  "<="
    LessEqualGreater =  "<>="
    LessOrGreater =  "<>"
    LogicAnd =  "&&"
    LogicOr =  "||"
    LParen =  "("
    Minus =  "-"
    MinusEqual =  "-="
    Mod =  "%"
    ModEqual =  "%="
    MulEqual =  "*="
    Not =  "!"
    NotEqual =  "!="
    NotGreater =  "!>"
    NotGreaterEqual =  "!>="
    NotLess =  "!<"
    NotLessEqual =  "!<="
    NotLessEqualGreater =  "!<>"
    Plus =  "+"
    PlusEqual =  "+="
    Pow =  "^^"
    PowEqual =  "^^="
    RBrace =  "}"
    RBracket =  "]"
    RParen =  ")"
    Semicolon =  ""
    ShiftLeft =  "<<"
    ShiftLeftEqual =  "<<="
    ShiftRight =  ">>"
    ShiftRightEqual =  ">>="
    Slice =  ".."
    Star =  "*"
    Ternary =  "?"
    Tilde =  "~"
    Unordered =  "!<>="
    UnsignedShiftRight =  ">>>"
    UnsignedShiftRightEqual =  ">>>="
    Vararg =  "..."
    Xor =  "^"
    XorEqual =  "^="
    Bool =  "bool"
    Byte =  "byte"
    Cdouble =  "cdouble"
    Cent =  "cent"
    Cfloat =  "cfloat"
    Char =  "char"
    Creal =  "creal"
    Dchar =  "dchar"
    Double =  "double"
    Float =  "float"
    Function =  "function"
    Idouble =  "idouble"
    Ifloat =  "ifloat"
    Int =  "int"
    Ireal =  "ireal"
    Long =  "long"
    Real =  "real"
    Short =  "short"
    Ubyte =  "ubyte"
    Ucent =  "ucent"
    Uint =  "uint"
    Ulong =  "ulong"
    Ushort =  "ushort"
    Void =  "void"
    Wchar =  "wchar"
    Align =  "align"
    TDeprecated =  "deprecated"
    Extern =  "extern"
    Pragma =  "pragma"
    Export =  "export"
    Package =  "package"
    Private =  "private"
    Protected =  "protected"
    Public =  "public"
    Abstract =  "abstract"
    Auto =  "auto"
    Const =  "const"
    Final =  "final"
    Gshared =  "__gshared"
    Immutable =  "immutable"
    Inout =  "inout"
    Scope =  "scope"
    Shared =  "shared"
    Static =  "static"
    Synchronized =  "synchronized"
    Alias =  "alias"
    Asm =  "asm"
    Assert =  "assert"
    Body =  "body"
    Break =  "break"
    Case =  "case"
    Cast =  "cast"
    TCatch =  "catch"
    Class =  "class"
    Continue =  "continue"
    Debug =  "debug"
    Default =  "default"
    Delegate =  "delegate"
    Delete =  "delete"
    Do =  "do"
    Else =  "else"
    Enum =  "enum"
    False =  "false"
    TFinally =  "finally"
    Foreach =  "foreach"
    Foreach_reverse =  "foreach_reverse"
    For =  "for"
    Goto =  "goto"
    If =  "if"
    Import =  "import"
    In =  "in"
    Interface =  "interface"
    TInvariant =  "invariant"
    Is =  "is"
    Lazy =  "lazy"
    Macro =  "macro"
    Mixin =  "mixin"
    TModule =  "module"
    New =  "new"
    Nothrow =  "nothrow"
    Null =  "null"
    Out =  "out"
    Override =  "override"
    Pure =  "pure"
    Ref =  "ref"
    Return =  "return"
    Struct =  "struct"
    Super =  "super"
    Switch =  "switch"
    Template =  "template"
    This =  "this"
    Throw =  "throw"
    True =  "true"
    Try =  "try"
    Typedef =  "typedef"
    Typeid =  "typeid"
    Typeof =  "typeof"
    Union =  "union"
    TUnittest =  "unittest"
    Version =  "version"
    Volatile =  "volatile"
    While =  "while"
    With =  "with"
    SpecialDate = "__DATE__"
    SpecialEof = "__EOF__"
    SpecialTime = "__TIME__"
    Specialimestamp = "__TIMESTAMP__"
    SpecialVendor = "__VENDOR__"
    SpecialVersion = "__VERSION__"
    SpecialFile = "__FILE__"
    SpecialLine = "__LINE__"
    SpecialModule = "__MODULE__"
    SpecialFunction = "__FUNCTION__"
    SpecialPrettyFunction = "__PRETTY_FUNCTION__"
    Traits = "__traits"
    TParameters = "__parameters"
    TVector = "__vector"
    
    Identifier="regexp:([a-zA-Z_])([a-zA-Z0-9_])*"

    Whitespace = "regexp:[\ \t\f]"
    NewLine = "regexp:[\n\r]+"
    EOL = "regexp:[\Z]"

    Character = "regexp:[^\r\n]"
    Letter = "regexp:[\w]"
    Digit = "regexp:[\d]"
    HexDigit = "regexp:[0-9abcdefABCDEF_]"
    OctalDigit = "regexp:[0-7]"
    NamedCharacterEntity = "regexp:&([a-zA-Z_])([a-zA-Z0-9_])*;"

    WYSIWYG_STRING = "regexp:r\"[^\"]*\"[cwd]*"
    AlternateWysiwygString = "regexp:`[^`]*`[cwd]*"

    DoubleQuotedString = 'regexp:\"([^\\"]|((\\"|\\\?|\\\|\\0|\\a|\\b|\\f|\\n|\\r|\\t|\\v)|(\\x[0-9abcdefABCDEF_]{2})|(\\[0-7])|(\\[0-7]{2})|(\\[0-7]{3})|(\\u[0-9abcdefABCDEF_]{4})|(\\U[0-9abcdefABCDEF_]{8})|(\\&([a-zA-Z_])([a-zA-Z0-9_])*;)))*\"[cwd]*'
    HexString = 'regexp:x\"([0-9a-fA-F][0-9a-fA-F]|[\r\n\s])*\"[cwd]*'

    line_comment="regexp://.*"
    block_comment="regexp:/\*(.|\n)*\*/"
  ]


}

private item_ ::= (moduleDeclaration | declaration)

  StringLiteral  ::= (WYSIWYG_STRING | AlternateWysiwygString | DoubleQuotedString | HexString)
  IntegerLiteral ::= 'regexp:\d+?'
  FloatLiteral ::= 'regexp:\d+?'
  
addExpression ::= mulExpression | addExpression ( '+' | '-' | '~' ) mulExpression

 aliasDeclaration ::= 'alias' aliasInitializer ( ',' aliasInitializer )* ';' | 'alias' storageClass* type identifierList ';'

 aliasInitializer ::= Identifier templateParameters? '=' storageClass* type

 aliasThisDeclaration ::= 'alias' Identifier 'this' ';'

 alignAttribute ::= 'align' ( '(' IntegerLiteral ')' )?

 andAndExpression ::= orExpression | andAndExpression '&amp;&amp;' orExpression

 andExpression ::= cmpExpression | andExpression '&amp;' cmpExpression

 argumentList ::= assignExpression ( ',' assignExpression? )*

 arguments ::= '(' argumentList? ')'

 arrayInitializer ::= '[' ']' | '[' arrayMemberInitialization ( ',' arrayMemberInitialization? )* ']'

 arrayLiteral ::= '[' argumentList? ']'

 arrayMemberInitialization ::= ( assignExpression ':' )? nonVoidInitializer

 asmAddExp ::= asmMulExp | asmAddExp ( '+' | '-' ) asmMulExp

 asmAndExp ::= asmEqualExp | asmAndExp '&amp;' asmEqualExp

 asmBrExp ::= asmUnaExp | asmBrExp? '[' asmExp ']'

 asmEqualExp ::= asmRelExp | asmEqualExp ( | ) asmRelExp

 asmExp ::= asmLogOrExp ( '?' asmExp ':' asmExp )?

 asmInstruction ::= Identifier | 'align' IntegerLiteral | 'align' Identifier | Identifier ':' asmInstruction | Identifier operands | 'in' operands | 'out' operands | 'int' operands

 asmLogAndExp ::= asmOrExp asmLogAndExp '&amp;&amp;' asmOrExp

 asmLogOrExp ::= asmLogAndExp | asmLogOrExp | | asmLogAndExp

 asmMulExp ::= asmBrExp | asmMulExp ( '*' | '/' | '%' ) asmBrExp

 asmOrExp ::= asmXorExp | asmOrExp '|' asmXorExp

 asmPrimaryExp ::= IntegerLiteral | FloatLiteral | StringLiteral | register | identifierChain | '$'

 asmRelExp ::= asmShiftExp | asmRelExp ( ( '&lt;' | '&lt;=' | '&gt;' | '&gt;=' ) asmShiftExp )?

 asmShiftExp ::= asmAddExp asmShiftExp ( '&lt;&lt;' | '&gt;&gt;' | '&gt;&gt;&gt;' ) asmAddExp

 asmStatement ::= 'asm' functionAttributes? '{' asmInstruction '}'

 asmTypePrefix ::= Identifier Identifier? | 'byte' Identifier? | 'short' Identifier? | 'int' Identifier? | 'float' Identifier? | 'double' Identifier? | 'real' Identifier?

 asmUnaExp ::= asmTypePrefix asmExp | Identifier asmExp | '+' asmUnaExp | '-' asmUnaExp | '!' asmUnaExp | '~' asmUnaExp | asmPrimaryExp

 asmXorExp ::= asmAndExp | asmXorExp '^' asmAndExp

 assertExpression ::= 'assert' '(' assignExpression ( ',' assignExpression )? ')'

 assignExpression ::= ternaryExpression (assignOperator expression)?

 assignOperator ::= '=' | '&gt;&gt;&gt;=' | '&gt;&gt;=' | '&lt;&lt;=' | '+=' | '-=' | '*=' | '%=' | '&amp;=' | '/=' | '|=' | '^^=' | '^=' | '~='

 assocArrayLiteral ::= '[' keyValuePairs ']'

 atAttribute ::= '@' Identifier | '@' Identifier '(' argumentList? ')' | '@' '(' argumentList ')'

 attribute ::= | pragmaExpression | alignAttribute | deprecated | atAttribute | linkageAttribute | 'export' | 'package' | 'private' | 'protected' | 'public' | 'static' | 'extern' | 'abstract' | 'final' | 'override' | 'synchronized' | 'auto' | 'scope' | 'const' | 'immutable' | 'inout' | 'shared' | '_gshared' | 'nothrow' | 'pure' | 'ref'

 attributeDeclaration ::= attribute ':'

 autoDeclaration ::= storageClass Identifier '=' initializer ( ',' Identifier '=' initializer )* ';'

 blockStatement ::= '{' declarationsAndStatements? '}'

 bodyStatement ::= 'body' blockStatement

 breakStatement ::= 'break' Identifier? ';'

 baseClass ::= type2

 baseClassList ::= baseClass ( ',' baseClass )*

 builtinType ::= 'bool' | 'byte' | 'ubyte' | 'short' | 'ushort' | 'int' | 'uint' | 'long' | 'ulong' | 'char' | 'wchar' | 'dchar' | 'float' | 'double' | 'real' | 'ifloat' | 'idouble' | 'ireal' | 'cfloat' | 'cdouble' | 'creal' | 'void'

 caseRangeStatement ::= 'case' assignExpression ':' '...' 'case' assignExpression ':' declarationsAndStatements

 caseStatement ::= 'case' argumentList ':' declarationsAndStatements

 castExpression ::= 'cast' '(' ( type | castQualifier )? ')' unaryExpression

 castQualifier ::= 'const' | 'const' 'shared' | 'immutable' | 'inout' | 'inout' 'shared' | 'shared' | 'shared' 'const' | 'shared' 'inout'

 catch ::= 'catch' '(' type Identifier? ')' declarationOrStatement

 catches ::= catch | catch* lastCatch

 classDeclaration ::= 'class' Identifier ';' | 'class' Identifier ( ':' baseClassList )? structBody | 'class' Identifier templateParameters constraint? ( structBody | ';' ) | 'class' Identifier templateParameters constraint? ( ':' baseClassList )? structBody | 'class' Identifier templateParameters ( ':' baseClassList )? constraint? structBody

 cmpExpression ::= shiftExpression | equalExpression | identityExpression | relExpression | inExpression

 compileCondition ::= versionCondition | debugCondition | staticIfCondition

 conditionalDeclaration ::= compileCondition declaration | compileCondition ':' declaration | compileCondition declaration 'else' declaration

 conditionalStatement ::= compileCondition declarationOrStatement ( 'else' declarationOrStatement )?

 constraint ::= 'if' '(' expression ')'

 constructor ::= 'this' templateParameters? parameters memberFunctionAttribute* constraint? ( functionBody | ';' )

 continueStatement ::= 'continue' Identifier? ';'

 debugCondition ::= 'debug' ( '(' ( IntegerLiteral | Identifier ) ')' )?

 debugSpecification ::= 'debug' '=' ( Identifier | IntegerLiteral ) ';'

 declaration ::= attribute* declaration2

 declaration2 ::= aliasDeclaration | aliasThisDeclaration | anonymousEnumDeclaration | attributeDeclaration | classDeclaration | conditionalDeclaration | constructor | debugSpecification | destructor | enumDeclaration | eponymousTemplateDeclaration | functionDeclaration | importDeclaration | interfaceDeclaration | invariant | mixinDeclaration | mixinTemplateDeclaration | pragmaDeclaration | sharedStaticConstructor | sharedStaticDestructor | staticAssertDeclaration | staticConstructor | staticDestructor | structDeclaration | templateDeclaration | unionDeclaration | unittest | variableDeclaration | versionSpecification | '{' declaration '}'

 declarationsAndStatements ::= declarationOrStatement

 declarationOrStatement ::= declaration | statement

 declarator ::= Identifier | Identifier '=' initializer | Identifier templateParameters '=' initializer

 defaultStatement ::= 'default' ':' declarationsAndStatements

 deleteExpression ::= 'delete' unaryExpression

 deprecated ::= 'deprecated' ( '(' StringLiteral ')' )?

 destructor ::= '~' 'this' '(' ')' memberFunctionAttribute* ( functionBody | ';' )

 doStatement ::= 'do' statementNoCaseNoDefault 'while' '(' expression ')' ';'

 enumBody ::= '{' enumMember ( ',' enumMember? )* '}'

 anonymousEnumMember ::= type identifier '=' assignExpression | identifier '=' assignExpression | identifier

 anonymousEnumDeclaration ::= 'enum' ( ':' type )? '{' anonymousEnumMember '}'

 enumDeclaration ::= 'enum' Identifier ( ':' type )? ';' | 'enum' Identifier ( ':' type )? enumBody

 enumMember ::= Identifier | Identifier '=' assignExpression

 eponymousTemplateDeclaration ::= 'enum' Identifier templateParameters '=' assignExpression ';'

 equalExpression ::= shiftExpression ( '==' | '!=' ) shiftExpression

 expression ::= assignExpression ( ',' assignExpression )*

 expressionStatement ::= expression ';'

 finalSwitchStatement ::= 'final' switchStatement

 finally ::= 'finally' declarationOrStatement

 forStatement ::= 'for' '(' ( declaration | statementNoCaseNoDefault ) expression? ';' expression? ')' declarationOrStatement

 foreachStatement ::= ( 'foreach' | 'foreach_reverse' ) '(' foreachTypeList ';' expression ')' declarationOrStatement | ( 'foreach' | 'foreach_reverse' ) '(' foreachType ';' expression '..' expression ')' declarationOrStatement

 foreachType ::= 'ref'? typeConstructors? type? Identifier | typeConstructors? 'ref'? type? Identifier

 foreachTypeList ::= foreachType ( ',' foreachType )*

 functionAttribute ::= atAttribute | 'pure' | 'nothrow'

 functionBody ::= blockStatement | ( inStatement | outStatement | outStatement inStatement | inStatement outStatement )? bodyStatement?

 functionCallExpression ::= symbol arguments unaryExpression arguments | type arguments

 functionDeclaration ::= ( storageClass | type ) Identifier parameters memberFunctionAttribute* ( functionBody | ';' ) | ( storageClass | type ) Identifier templateParameters parameters memberFunctionAttribute* constraint? ( functionBody | ';' )

 functionLiteralExpression ::= ( ( 'function' | 'delegate' ) type? )? ( parameters functionAttribute* )? functionBody

 gotoStatement ::= 'goto' ( Identifier | 'default' | 'case' expression? ) ';'

 identifierChain ::= Identifier ( '.' Identifier )*

 identifierList ::= Identifier ( ',' Identifier )*

 identifierOrTemplateChain ::= identifierOrTemplateInstance ( '.' identifierOrTemplateInstance )*

 identifierOrTemplateInstance ::= Identifier | templateInstance

 identityExpression ::= shiftExpression ( 'is' | ( '!' 'is' ) ) shiftExpression

 ifStatement ::= 'if' '(' ifCondition ')' declarationOrStatement ( 'else' declarationOrStatement )?

 ifCondition ::= 'auto' Identifier '=' expression | type Identifier '=' expression | expression

 importBind ::= Identifier ( '=' Identifier )?

 importBindings ::= singleImport ':' importBind ( ',' importBind )*

 importDeclaration ::= 'import' singleImport ( ',' singleImport )* (',' importBindings)? ';' | 'import' importBindings ';'

 importExpression ::= 'import' '(' assignExpression ')'

 indexExpression ::= unaryExpression '[' argumentList ']'

 inExpression ::= shiftExpression ( 'in' | ( '!' 'in' ) ) shiftExpression

 inStatement ::= 'in' blockStatement

 initializer ::= 'void' | nonVoidInitializer

 interfaceDeclaration ::= 'interface' Identifier ';' | 'interface' Identifier ( ':' baseClassList )? structBody | 'interface' Identifier templateParameters constraint? ( ':' baseClassList )? structBody | 'interface' Identifier templateParameters ( ':' baseClassList )? constraint? structBody

 invariant ::= 'invariant' ( '(' ')' )? blockStatement

 isExpression ::= 'is' '(' type identifier? ')' 'is' '(' type identifier? ':' typeSpecialization ')' 'is' '(' type identifier? '=' typeSpecialization ')' 'is' '(' type identifier? ':' typeSpecialization ',' templateParameterList ')' 'is' '(' type identifier? '=' typeSpecialization ',' templateParameterList ')'

 keyValuePair ::= assignExpression ':' assignExpression

 keyValuePairs ::= keyValuePair ( ',' keyValuePair )* ','?

 labeledStatement ::= Identifier ':' declarationOrStatement?

 lambdaExpression ::= Identifier '=&gt;' assignExpression | 'function' type? parameters functionAttribute* '=&gt;' assignExpression | 'delegate' type? parameters functionAttribute* '=&gt;' assignExpression | parameters functionAttribute* '=&gt;' assignExpression

 lastCatch ::= 'catch' statementNoCaseNoDefault

 linkageAttribute ::= 'extern' '(' Identifier ( '++' ( ',' identifierChain )? )? ')'

 memberFunctionAttribute ::= functionAttribute | 'immutable' | 'inout' | 'shared' | 'const' | 'return'

 mixinDeclaration ::= mixinExpression ';' | templateMixinExpression ';'

 mixinExpression ::= 'mixin' '(' assignExpression ')'

 mixinTemplateDeclaration ::= 'mixin' templateDeclaration

 mixinTemplateName ::= symbol | typeofExpression '.' identifierOrTemplateChain

 module ::= moduleDeclaration? declaration*

 moduleDeclaration ::= deprecated? 'module' identifierChain ';'

 mulExpression ::= powExpression | mulExpression ( '*' | '/' | '%' ) powExpression

 newAnonClassExpression ::= 'new' arguments? 'class' arguments? baseClassList? structBody

 newExpression ::= 'new' type ( ( '[' assignExpression ']' ) | arguments )? | newAnonClassExpression

 nonVoidInitializer ::= assignExpression | arrayInitializer | structInitializer

 operands ::= asmExp | asmExp ',' operands

 orExpression ::= xorExpression | orExpression '|' xorExpression

 orOrExpression ::= andAndExpression | orOrExpression '||' andAndExpression

 outStatement ::= 'out' ( '(' Identifier ')' )? blockStatement

 parameter ::= parameterAttribute* type parameterAttribute* type Identifier? '...' parameterAttribute* type Identifier? ( '=' assignExpression )?

 parameterAttribute ::= typeConstructor | 'final' | 'in' | 'lazy' | 'out' | 'ref' | 'scope' | 'auto' | 'return'

 parameters ::= '(' parameter ( ',' parameter )* ( ',' '...' )? ')' | '(' '...' ')' | '(' ')'

 postblit ::= 'this' '(' 'this' ')' memberFunctionAttribute* ( functionBody | ';' )

 powExpression ::= unaryExpression | powExpression '^^' unaryExpression

 pragmaDeclaration ::= pragmaExpression ';'

 pragmaExpression ::= '(' Identifier ( ',' argumentList )? ')'

 primaryExpression ::= identifierOrTemplateInstance | '.' identifierOrTemplateInstance | typeConstructor '(' basicType ')' '.' Identifier | basicType '.' Identifier | basicType arguments | typeofExpression | typeidExpression | vector | arrayLiteral | assocArrayLiteral | '(' expression ')' | isExpression | lambdaExpression | functionLiteralExpression | traitsExpression | mixinExpression | importExpression | '$' | 'this' | 'super' | 'null' | 'true' | 'false' | '__DATE__' | '__TIME__' | '__TIMESTAMP__' | '__VENDOR__' | '__VERSION__' | '__FILE__' | '__LINE__' | '__MODULE__' | '__FUNCTION__' | '__PRETTY_FUNCTION__' | IntegerLiteral | FloatLiteral | StringLiteral | CharacterLiteral

 register ::= Identifier | Identifier '(' IntegerLiteral ')'

 relExpression ::= shiftExpression | relExpression relOperator shiftExpression

 relOperator ::= '&lt;' | '&lt;=' | '&gt;' | '&gt;=' | '!&lt;&gt;=' | '!&lt;&gt;' | '&lt;&gt;' | '&lt;&gt;=' | '!&gt;' | '!&gt;=' | '!&lt;' | '!&lt;='

 returnStatement ::= 'return' expression? ';'

 scopeGuardStatement ::= 'scope' '(' Identifier ')' statementNoCaseNoDefault

 sharedStaticConstructor ::= 'shared' 'static' 'this' '(' ')' functionBody

 sharedStaticDestructor ::= 'shared' 'static' '~' 'this' '(' ')' functionBody

 shiftExpression ::= addExpression | shiftExpression ( '&lt;&lt;' | '&gt;&gt;' | '&gt;&gt;&gt;' ) addExpression

 singleImport ::= ( Identifier '=' )? identifierChain

 sliceExpression ::= unaryExpression '[' assignExpression '..' assignExpression ']' | unaryExpression '[' ']'

 statement ::= statementNoCaseNoDefault | caseStatement | caseRangeStatement | defaultStatement

 statementNoCaseNoDefault ::= labeledStatement | blockStatement | ifStatement | whileStatement | doStatement | forStatement | foreachStatement | switchStatement | finalSwitchStatement | continueStatement | breakStatement | returnStatement | gotoStatement | withStatement | synchronizedStatement | tryStatement | throwStatement | scopeGuardStatement | asmStatement | conditionalStatement | staticAssertStatement | versionSpecification | debugSpecification | expressionStatement

 staticAssertDeclaration ::= staticAssertStatement

 staticAssertStatement ::= 'static' assertExpression ';'

 staticConstructor ::= 'static' 'this' '(' ')' functionBody

 staticDestructor ::= 'static' '~' 'this' '(' ')' functionBody

 staticIfCondition ::= 'static' 'if' '(' assignExpression ')'

 storageClass ::= alignAttribute | linkageAttribute | atAttribute | typeConstructor | deprecated | 'abstract' | 'auto' | 'enum' | 'extern' | 'final' | 'nothrow' | 'override' | 'pure' | 'ref' | '__gshared' | 'scope' | 'static' | 'synchronized'

 structBody ::= '{' declaration* '}'

 structDeclaration ::= 'struct' Identifier? ( templateParameters constraint? structBody | ( structBody | ';' ) )

 structInitializer ::= '{' structMemberInitializers? '}'

 structMemberInitializer ::= ( Identifier ':' )? nonVoidInitializer

 structMemberInitializers ::= structMemberInitializer ( ',' structMemberInitializer? )*

 switchStatement ::= 'switch' '(' expression ')' statement

 symbol ::= '.'? identifierOrTemplateChain

 synchronizedStatement ::= 'synchronized' ( '(' expression ')' )? statementNoCaseNoDefault

 templateAliasParameter ::= 'alias' type? Identifier ( ':' ( type | assignExpression ) )? ( '=' ( type | assignExpression ) )?

 templateArgument ::= type | assignExpression

 templateArgumentList ::= templateArgument ( ',' templateArgument? )*

 templateArguments ::= '!' ( '(' templateArgumentList? ')' ) | templateSingleArgument

 templateDeclaration ::= 'template' Identifier templateParameters constraint? '{' declaration* '}'

 templateInstance ::= Identifier templateArguments

 templateMixinExpression ::= 'mixin' mixinTemplateName templateArguments? Identifier?

 templateParameter ::= templateTypeParameter | templateValueParameter | templateAliasParameter | templateTupleParameter | templateThisParameter

 templateParameterList ::= templateParameter ( ',' templateParameter? )*

 templateParameters ::= '(' templateParameterList? ')'

 templateSingleArgument ::= builtinType | Identifier | CharacterLiteral | StringLiteral | IntegerLiteral | FloatLiteral | 'true' | 'false' | 'null' | 'this' | '__DATE__' | '__TIME__' | '__TIMESTAMP__' | '__VENDOR__' | '__VERSION__' | '__FILE__' | '__LINE__' | '__MODULE__' | '__FUNCTION__' | '__PRETTY_FUNCTION__'

 templateThisParameter ::= 'this' templateTypeParameter

 templateTupleParameter ::= Identifier '...'

 templateTypeParameter ::= Identifier ( ':' type )? ( '=' type )?

 templateValueParameter ::= type Identifier ( ':' assignExpression )? templateValueParameterDefault?

 templateValueParameterDefault ::= '=' ( '__FILE__' | '__MODULE__' | '__LINE__' | '__FUNCTION__' | '__PRETTY_FUNCTION__' | assignExpression )

 ternaryExpression ::= orOrExpression ( '?' expression ':' ternaryExpression )?

 throwStatement ::= 'throw' expression ';'

 traitsExpression ::= '__traits' '(' Identifier ',' TemplateArgumentList ')'

 tryStatement ::= 'try' declarationOrStatement ( catches | catches finally | finally )

 type ::= typeConstructors? type2 typeSuffix*

 type2 ::= builtinType | symbol | typeofExpression ( '.' identifierOrTemplateChain )? | typeConstructor '(' type ')' | vector

 typeConstructor ::= 'const' | 'immutable' | 'inout' | 'shared'

 typeConstructors ::= typeConstructor

 typeSpecialization ::= type | 'struct' | 'union' | 'class' | 'interface' | 'enum' | 'function' | 'delegate' | 'super' | 'const' | 'immutable' | 'inout' | 'shared' | 'return' | 'typedef' | '__parameters'

 typeSuffix ::= '*' | '[' type? ']' | '[' assignExpression ']' | '[' assignExpression '..' assignExpression ']' | ( 'delegate' | 'function' ) parameters memberFunctionAttribute*

 typeidExpression ::= 'typeid' '(' ( type | expression ) ')'

 typeofExpression ::= 'typeof' '(' ( expression | 'return' ) ')'

 unaryExpression ::= primaryExpression | '&amp;' unaryExpression | '!' unaryExpression | '*' unaryExpression | '+' unaryExpression | '-' unaryExpression | '~' unaryExpression | '++' unaryExpression | '--' unaryExpression | newExpression | deleteExpression | castExpression | assertExpression | functionCallExpression | sliceExpression | indexExpression | '(' type ')' '.' identifierOrTemplateInstance | unaryExpression '.' identifierOrTemplateInstance | unaryExpression '--' | unaryExpression '++'

 unionDeclaration ::= 'union' Identifier templateParameters constraint? structBody | 'union' Identifier ( structBody | ';' ) | 'union' structBody

 unittest ::= 'unittest' blockStatement

 variableDeclaration ::= storageClass* type declarator ( ',' declarator )* ';' | storageClass* type identifier '=' functionBody ';' | autoDeclaration

 vector ::= '__vector' '(' type ')'

 versionCondition ::= 'version' '(' ( IntegerLiteral | Identifier | 'unittest' | 'assert' ) ')'

 versionSpecification ::= 'version' '=' ( Identifier | IntegerLiteral ) ';'

 whileStatement ::= 'while' '(' expression ')' declarationOrStatement

 withStatement ::= 'with' '(' expression ')' statementNoCaseNoDefault

 xorExpression ::= andExpression | xorExpression '^' andExpression