{

  parserClass="net.masterthought.dlanguage.parser.DLanguageParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="DLanguage"
  psiImplClassSuffix="Impl"
  psiPackage="net.masterthought.dlanguage.psi"
  psiImplPackage="net.masterthought.dlanguage.psi.impl"

  elementTypeHolderClass="net.masterthought.dlanguage.psi.DLanguageTypes"
  elementTypeClass="net.masterthought.dlanguage.psi.DLanguageElementType"
  tokenTypeClass="net.masterthought.dlanguage.psi.DLanguageTokenType"

  generateTokenAccessors=true

tokens = [
 KW_MODULE = "module"
 KW_IMPORT = "import"
 KW_STATIC = "static"
 KW_BOOL = "bool"
 KW_BYTE = "byte"
 KW_UBYTE = "ubyte"
 KW_SHORT = "short"
 KW_USHORT = "ushort"
 KW_INT = "int"
 KW_UINT = "uint"
 KW_LONG = "long"
 KW_ULONG = "ulong"
 KW_CHAR = "char"
 KW_WCHAR = "wchar"
 KW_DCHAR = "dchar"
 KW_FLOAT = "float"
 KW_DOUBLE = "double"
 KW_REAL = "real"
 KW_IFLOAT = "ifloat"
 KW_IDOUBLE = "idouble"
 KW_IREAL = "ireal"
 KW_CFLOAT = "cfloat"
 KW_CDOUBLE = "cdouble"
 KW_CREAL = "creal"
 KW_VOID = "void"
 KW_TYPEOF = "typeof"
 KW_CONST = "const"
 KW_IMMUTABLE = "immutable"
 KW_SHARED = "shared"
 KW_INOUT = "inout"
 KW_DELEGATE = "delegate"
 KW_FUNCTION = "function"
 KW_NOTHROW = "nothrow"
 KW_PURE = "pure"
 KW_THIS = "this"
 KW___FILE__ = "__FILE__"
 KW___MODULE__ = "__MODULE__"
 KW___LINE__ = "__LINE__"
 KW___FUNCTION__ = "__FUNCTION__"
 KW___PRETTY_FUNCTION__ = "__PRETTY_FUNCTION__"
 KW_ABSTRACT = "abstract"
 KW_ALIAS = "alias"
 KW_AUTO = "auto"
 KW_DEPRECATED = "deprecated"
 KW_ENUM = "enum"
 KW_EXTERN = "extern"
 KW_FINAL = "final"
 KW_OVERRIDE = "override"
 KW___GSHARED = "__gshared"
 KW_SCOPE = "scope"
 KW_SYNCHRONIZED = "synchronized"
 KW_RETURN = "return"
 KW_SUPER = "super"
 KW_ALIGN = "align"
 KW_PRAGMA = "pragma"
 KW_PACKAGE = "package"
 KW_PRIVATE = "private"
 KW_PROTECTED = "protected"
 KW_PUBLIC = "public"
 KW_EXPORT = "export"
 KW_PROPERTY = "property"
 KW_SAFE = "safe"
 KW_TRUSTED = "trusted"
 KW_SYSTEM = "system"
 KW_DISABLE = "disable"
 KW_DELETE = "delete"
 KW_NULL = "null"
 KW_TRUE = "true"
 KW_FALSE = "false"
 KW_NEW = "new"
 KW_TYPEID = "typeid"
 KW_IS = "is"
 KW_STRUCT = "struct"
 KW_UNION = "union"
 KW_CLASS = "class"
 KW_INTERFACE = "interface"
 KW___PARAMETERS = "__parameters"
 KW_IN = "in"
 KW_ASM = "asm"
 KW_ASSERT = "assert"
 KW_CASE = "case"
 KW_CAST = "cast"
 KW_REF = "ref"
 KW_BREAK = "break"
 KW_CONTINUE = "continue"
 KW_DO = "do"
 KW_ELSE = "else"
 KW_FOR = "for"
 KW_FOREACH = "foreach"
 KW_FOREACH_REVERSE = "foreach_reverse"
 KW_GOTO = "goto"
 KW_IF = "if"
 KW_CATCH = "catch"
 KW_FINALLY = "finally"
 KW_SWITCH = "switch"
 KW_THROW = "throw"
 KW_TRY = "try"
 KW_DEFAULT = "default"
 KW_WHILE = "while"
 KW_WITH = "with"
 KW_VERSION = "version"
 KW_DEBUG = "debug"
 KW_MIXIN = "mixin"
 KW_INVARIANT = "invariant"
 KW_BODY = "body"
 KW_TEMPLATE = "template"
 KW_LAZY = "lazy"
 KW_OUT = "out"
 KW_NOGC = "nogc"
 KW___TRAITS = "__traits"
 KW_UNITTEST = "unittest"
 OP_SCOLON = ";"
 OP_COLON = ":"
 OP_EQ = "="
 OP_COMMA = ","
 OP_PAR_LEFT = "("
 OP_PAR_RIGHT = ")"
 OP_BRACKET_LEFT = "["
 OP_BRACKET_RIGHT = "]"
 OP_BRACES_LEFT = "{"
 OP_BRACES_RIGHT = "}"
 OP_ASTERISK = "*"
 OP_DDOT = ".."
 OP_TRIPLEDOT = "..."
 OP_AT = "@"
 OP_PLUS_EQ = "+="
 OP_MINUS_EQ = "-="
 OP_MUL_EQ = "*="
 OP_DIV_EQ = "/="
 OP_MOD_EQ = "%="
 OP_AND_EQ = "&="
 OP_OR_EQ = "|="
 OP_XOR_EQ = "^="
 OP_TILDA_EQ = "~="
 OP_SH_LEFT_EQ = "<<="
 OP_SH_RIGHT_EQ = ">>="
 OP_USH_RIGHT_EQ = ">>>="
 OP_POW_EQ = "^^="
 OP_QUEST = "?"
 OP_BOOL_OR = "||"
 OP_BOOL_AND = "&&"
 OP_OR = "|"
 OP_XOR = "^"
 OP_SH_LEFT = "<<"
 OP_SH_RIGHT = ">>"
 OP_USH_RIGHT = ">>>"
 OP_PLUS = "+"
 OP_MINUS = "-"
 OP_TILDA = "~"
 OP_DIV = "/"
 OP_MOD = "%"
 OP_AND = "&"
 OP_PLUS_PLUS = "++"
 OP_MINUS_MINUS = "--"
 OP_NOT = "!"
 OP_POW = "^^"
 OP_DOLLAR = "$"
 OP_EQ_EQ = "=="
 OP_NOT_EQ = "!="
 OP_LESS = "<"
 OP_LESS_EQ = "<="
 OP_GT = ">"
 OP_GT_EQ = ">="
 OP_UNORD = "!<>="
 OP_UNORD_EQ = "!<>"
 OP_LESS_GR = "<>"
 OP_LESS_GR_EQ = "<>="
 OP_NOT_GR = "!>"
 OP_NOT_GR_EQ = "!>="
 OP_NOT_LESS = "!<"
 OP_NOT_LESS_EQ = "!<="
 OP_LAMBDA_ARROW = "=>"
 OP_DOT = "."

ID = "regexp:\w+"

  space='regexp:\s+'

//  string_literal='regexp:"\w+"'
//  string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
//  number="regexp:\d+"
//  float="regexp:[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?"
  line_comment="regexp://.*"
  block_comment="regexp:/\*(.|\n)*\*/"

//   DoubleQuotedString = 'regexp:\"([^\\"]|((\\"|\\\?|\\\|\\0|\\a|\\b|\\f|\\n|\\r|\\t|\\v)|(\\x[0-9abcdefABCDEF_]{2})|(\\[0-7])|(\\[0-7]{2})|(\\[0-7]{3})|(\\u[0-9abcdefABCDEF_]{4})|(\\U[0-9abcdefABCDEF_]{8})|(\\&([a-zA-Z_])([a-zA-Z0-9_])*;)))*\"[cwd]*'
  //  HexString = 'regexp:x\"([0-9a-fA-F][0-9a-fA-F]|[\r\n\s])*\"[cwd]*'


]


}

dFile ::= item_*

// ----------------------------------------------------------


private item_ ::= ( moduleDeclaration | declaration | statement)

  Identifier ::= ID
  StringLiteral  ::= (WYSIWYG_STRING|ALTERNATE_WYSIWYG_STRING|DOUBLE_QUOTED_STRING|HEX_STRING|DELIMITED_STRING)


// investigate ::= 'investigate' ('+' | '-' | '/' | '*' | '&' | '&&' | '|' | '||' | '^' | '^^' | '%')

//  investigateExpression ::= investigate investigate

//  investigateExpression ::=
//        [investigateExpression 'and'] investigate

//  investigateExpression ::= investigate investigate2
//  private investigate2 ::= ['and' investigateExpression]

 // orOrExpression ::=
 //       andAndExpression
 //     | orOrExpression '||' andAndExpression

// orOrExpression ::= andAndExpression orOrExpression2
// private orOrExpression2 ::= '||' orOrExpression |

 aliasDeclaration ::=
       'alias' aliasInitializer (',' aliasInitializer)* ';'
     | 'alias' linkageAttribute? type Identifier ';'

 aliasInitializer ::=
     Identifier '=' type

 aliasThisDeclaration ::=
     'alias' Identifier 'this' ';'

// TODO 29
 alignAttribute ::=
     'align' ('(' INTEGER_LITERAL ')')?

 argumentList ::=
     assignExpression (',' assignExpression?)*

 arguments ::=
     '(' argumentList? ')'

 arrayInitializer ::=
       '[' ']'
     | '[' arrayMemberInitialization (',' arrayMemberInitialization?)* ']'

 arrayLiteral ::=
     '[' argumentList? ']'

 arrayMemberInitialization ::=
     (assignExpression ':')? nonVoidInitializer

 asmEqualExp ::=
     asmRelExp (('==' | '!=') asmRelExp)?

 asmExp ::=
     asmLogOrExp ('?' asmExp ':' asmExp)?

// TODO 24
 asmInstruction ::=
     Identifier
     | 'align' INTEGER_LITERAL
     | 'align' Identifier
     | Identifier ':' asmInstruction
     | Identifier asmExp
     | Identifier operands

 asmLogAndExp ::=
     asmOrExp ('&&' asmOrExp)?

 asmLogOrExp ::=
     asmLogAndExp ('||' asmLogAndExp)?

 asmMulExp ::=
     asmBrExp (('*' | '/' | '%') asmBrExp)?

 asmOrExp ::=
     asmXorExp ('|' asmXorExp)?

// TODO 23
 asmPrimaryExp ::=
       INTEGER_LITERAL
     | FLOAT_LITERAL
     | register
     | identifierChain
     | '$'

 asmRelExp ::=
     asmShiftExp (('<' | '<=' | '>' | '>=') asmShiftExp)?


 asmShiftExp ::=
     asmAddExp (('<<' | '>>' | '>>>') asmAddExp)?

 asmStatement ::=
     'asm' '{' asmInstruction+ '}'

 asmTypePrefix ::=
       Identifier Identifier
     | 'byte' Identifier
     | 'short' Identifier
     | 'int' Identifier
     | 'float' Identifier
     | 'double' Identifier
     | 'real' Identifier

 asmUnaExp ::=
       asmTypePrefix asmExp
     | Identifier asmExp
     | '+' asmUnaExp
     | '-' asmUnaExp
     | '!' asmUnaExp
     | '~' asmUnaExp
     | asmPrimaryExp

 asmXorExp ::=
     asmAndExp ('^' asmAndExp)?

 assertExpression ::=
     'assert' '(' assignExpression (',' assignExpression)? ')'

 assignExpression ::=
     ternaryExpression (assignOperator assignExpression)?

 assignOperator ::=
       '='
     | '>>>='
     | '>>='
     | '<<='
     | '+='
     | '-='
     | '*='
     | '%='
     | '&='
     | '/='
     | '|='
     | '^^='
     | '^='
     | '~='

 assocArrayLiteral ::=
     '[' keyValuePairs ']'

 atAttribute ::=
     '@' (Identifier | '(' argumentList ')' | functionCallExpression)

 attribute ::=
       alignAttribute
     | linkageAttribute
     | pragmaExpression
     | storageClass
     | 'export'
     | 'package'
     | 'private'
     | 'protected'
     | 'public'

 attributeDeclaration ::=
     attribute ':'

 autoDeclaration ::=
     storageClass Identifier '=' initializer (',' Identifier '=' initializer)* ';'

 blockStatement ::=
     '{' declarationsAndStatements? '}'

 bodyStatement ::=
     'body' blockStatement

 breakStatement ::=
     'break' Identifier? ';'

 baseClass ::=
     (typeofExpression '.')? identifierOrTemplateChain

 baseClassList ::=
     baseClass (',' baseClass)*

 builtinType ::=
      'bool'
    | 'byte'
    | 'ubyte'
    | 'short'
    | 'ushort'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    | 'wchar'
    | 'dchar'
    | 'float'
    | 'double'
    | 'real'
    | 'ifloat'
    | 'idouble'
    | 'ireal'
    | 'cfloat'
    | 'cdouble'
    | 'creal'
    | 'void'

 caseRangeStatement ::=
     'case' assignExpression ':' '...' 'case' assignExpression ':' declarationsAndStatements

 caseStatement ::=
     'case' argumentList ':' declarationsAndStatements

 castExpression ::=
     'cast' '(' (type | castQualifier)? ')' unaryExpression

 castQualifier ::=
      'const'
    | 'const' 'shared'
    | 'immutable'
    | 'inout'
    | 'inout' 'shared'
    | 'shared'
    | 'shared' 'const'
    | 'shared' 'inout'

 catch_ ::=
     'catch' '(' type Identifier? ')' declarationOrStatement

 catches ::=
       catch_+
     | catch_* lastCatch

 classDeclaration ::=
       'class' Identifier (':' baseClassList)? ';'
     | 'class' Identifier (':' baseClassList)? structBody
     | 'class' Identifier templateParameters constraint? (':' baseClassList)? structBody
     | 'class' Identifier templateParameters (':' baseClassList)? constraint? structBody

 cmpExpression ::=
       shiftExpression
     | equalExpression
     | identityExpression
     | relExpression
     | inExpression

 compileCondition ::=
       versionCondition
     | debugCondition
     | staticIfCondition

 conditionalDeclaration ::=
       compileCondition declaration
     | compileCondition ':' declaration+
     | compileCondition declaration ('else' declaration)?

 conditionalStatement ::=
     compileCondition declarationOrStatement ('else' declarationOrStatement)?

 constraint ::=
     'if' '(' expression ')'

 constructor ::=
       'this' templateParameters parameters memberFunctionAttribute* constraint? (functionBody | ';')

 continueStatement ::=
     'continue' Identifier? ';'

 debugCondition ::=
     'debug' ('(' (INTEGER_LITERAL | Identifier) ')')?

 debugSpecification ::=
     'debug' '=' (Identifier | INTEGER_LITERAL) ';'

declaration ::=
     attribute* declaration2

declaration2 ::=
     aliasDeclaration
   | aliasThisDeclaration
   | classDeclaration
   | conditionalDeclaration
   | constructor
   | destructor
   | enumDeclaration
   | functionDeclaration
   | importDeclaration
   | interfaceDeclaration
   | mixinDeclaration
   | mixinTemplateDeclaration
   | pragmaDeclaration
   | sharedStaticConstructor
   | sharedStaticDestructor
   | staticAssertDeclaration
   | staticConstructor
   | staticDestructor
   | structDeclaration
   | templateDeclaration
   | unionDeclaration
   | unittest
   | variableDeclaration
   | attributeDeclaration
   | invariant
   | '{' declaration+ '}'

 declarationsAndStatements ::=
     declarationOrStatement+

 declarationOrStatement ::=
       declaration
     | statement

 declarator ::=
     Identifier ('=' initializer)?

 defaultStatement ::=
     'default' ':' declarationsAndStatements

 deleteExpression ::=
     'delete' unaryExpression

 deprecated ::=
     'deprecated' ('(' assignExpression ')')?

 destructor ::=
     '~' 'this' '(' ')' memberFunctionAttribute* (functionBody | ';')

 doStatement ::=
     'do' statementNoCaseNoDefault 'while' '(' expression ')' ';'

//enumBody ::= ';' | '{' enumMember (',' enumMember?)* '}'
//
//
//enumDeclaration ::=
//     'enum' Identifier? (':' type)? enumBody
//
//enumMember ::= Identifier | (Identifier | type) '=' assignExpression

// ------ Enums -----

enumDeclaration ::=
    'enum' Identifier (':' type)? enumBody |
    'enum' Identifier enumBody |
    anonymousEnumDeclaration

enumBody ::=
    ';' | '{' enumMembers '}'


//enumMembers ::=
//    enumMember |
//    enumMember ',' |
//    enumMember ',' enumMembers

enumMembers ::=
    enumMember (',' enumMember?)* enumMembers?

//enumMember ::=
//    Identifier  |
//    Identifier '=' assignExpression

enumMember ::=
    Identifier ('=' assignExpression)?

anonymousEnumDeclaration ::=
    'enum' ':' type '{' enumMembers '}' |
    'enum' '{' enumMembers '}'          |
    'enum' '{' anonymousEnumMembers '}' |
    'enum' anonymousEnumMembers ';'

//anonymousEnumMembers ::=
//    anonymousEnumMember |
//    anonymousEnumMember ',' |
//    anonymousEnumMember ',' anonymousEnumMembers

anonymousEnumMembers ::=
    anonymousEnumMember (',' anonymousEnumMember?)* anonymousEnumMembers?

anonymousEnumMember ::=
    enumMember | type Identifier ('=' assignExpression)?

//anonymousEnumMember ::=
//    enumMember |
//    type Identifier '=' assignExpression

// ------------------



 equalExpression ::=
     shiftExpression ('==' | '!=') shiftExpression

 expression ::=
     assignExpression (',' assignExpression)*

 expressionStatement ::=
     expression ';'

 finalSwitchStatement ::=
     'final' switchStatement

 finally_ ::=
     'finally' declarationOrStatement

 forStatement ::=
     'for' '(' declarationOrStatement expression? ';' expression? ')' declarationOrStatement

 foreachStatement ::=
       ('foreach' | 'foreach_reverse') '(' foreachTypeList ';' expression ')' declarationOrStatement
     | ('foreach' | 'foreach_reverse') '(' foreachType ';' expression '..' expression ')' declarationOrStatement

 foreachType ::=
     typeConstructors? type? Identifier

 foreachTypeList ::=
     foreachType (',' foreachType)*

 functionAttribute ::=
       atAttribute
     | 'pure'
     | 'nothrow'

 functionBody ::=
       blockStatement
     | (inStatement | outStatement | outStatement inStatement | inStatement outStatement)? bodyStatement

 functionCallExpression ::=
       unaryExpression templateArguments? arguments
     | type arguments

functionCallStatement ::=
     functionCallExpression ';'
     ;

functionDeclaration ::=
       (storageClass+ | type) Identifier parameters memberFunctionAttribute* (functionBody | ';')
     | (storageClass+ | type) Identifier templateParameters parameters memberFunctionAttribute* constraint? (functionBody | ';')
     ;

 functionLiteralExpression ::=
     (('function' | 'delegate') type?)? (parameters functionAttribute*)? functionBody

 gotoStatement ::=
     'goto' (Identifier | 'default' | 'case' expression?) ';'

 identifierChain ::=
     Identifier ('.' Identifier)*

//TODO 20
// identifierList ::=
//     Identifier (',' Identifier)*
//     ;

 identifierOrTemplateChain ::=
     identifierOrTemplateInstance ('.' identifierOrTemplateInstance)*

 identifierOrTemplateInstance ::=
       Identifier
     | templateInstance

 identityExpression ::=
     shiftExpression ('is' | '!' 'is') shiftExpression

 ifStatement ::=
     'if' '(' ifCondition ')' declarationOrStatement ('else' declarationOrStatement)?

ifCondition ::=
       'auto' Identifier '=' expression
     | type Identifier '=' expression
     | expression

 importBind ::=
     Identifier ('=' Identifier)?

 importBindings ::=
     singleImport ':' importBind (',' importBind)*

 importDeclaration ::=
       'import' singleImport (',' singleImport)* (',' importBindings)? ';'
     | 'import' importBindings ';'

 importExpression ::=
     'import' '(' assignExpression ')'

// TODO 19
// indexExpression ::=
//     unaryExpression '[' argumentList ']'
//     ;

 inExpression ::=
     shiftExpression ('in' | '!' 'in') shiftExpression

 inStatement ::=
     'in' blockStatement

// TODO 18
// initialize ::=
//       ';'
//     | statementNoCaseNoDefault
//     ;

 initializer ::=
       'void'
     | nonVoidInitializer

 interfaceDeclaration ::=
     'interface' Identifier (';' | (templateParameters constraint?)? (':' baseClassList)? structBody)

 invariant ::=
     'invariant' ('(' ')')? blockStatement

 isExpression ::=
     'is' '(' type Identifier? ((':' | '==') typeSpecialization (',' templateParameterList)?)? ')'

 keyValuePair ::=
     assignExpression ':' assignExpression

 keyValuePairs ::=
     keyValuePair (',' keyValuePair)* ','?

 labeledStatement ::=
     Identifier ':' declarationOrStatement

 lambdaExpression ::=
       Identifier '=>' assignExpression
     | 'function' parameters functionAttribute* '=>' assignExpression
     | 'delegate' parameters functionAttribute* '=>' assignExpression
     | parameters functionAttribute* '=>' assignExpression

 lastCatch ::=
     'catch' statementNoCaseNoDefault

 linkageAttribute ::=
     'extern' '(' Identifier ('++' (',' identifierChain)?)? ')'

 memberFunctionAttribute ::=
       functionAttribute
     | 'immutable'
     | 'inout'
     | 'shared'
     | 'const'

 mixinDeclaration ::=
       mixinExpression ';'
     | templateMixinExpression ';'

 mixinExpression ::=
     'mixin' '(' assignExpression ')'

 mixinTemplateDeclaration ::=
     'mixin' templateDeclaration

 mixinTemplateName ::=
       symbol
     | typeofExpression '.' identifierOrTemplateChain


 moduleDeclaration ::=
     'module' identifierChain ';'

 newAnonClassExpression ::=
     'new' arguments? 'class' arguments? baseClassList? structBody

 newExpression ::=
       'new' type ('[' assignExpression ']' | arguments)?
     | newAnonClassExpression

 statementNoCaseNoDefault ::=
       labeledStatement
     | blockStatement
     | ifStatement
     | whileStatement
     | doStatement
     | forStatement
     | foreachStatement
     | switchStatement
     | finalSwitchStatement
     | continueStatement
     | breakStatement
     | returnStatement
     | gotoStatement
     | withStatement
     | synchronizedStatement
     | tryStatement
     | throwStatement
     | scopeGuardStatement
     | asmStatement
     | conditionalStatement
     | staticAssertStatement
     | versionSpecification
     | debugSpecification
     | expressionStatement
     | functionCallStatement

 nonVoidInitializer ::=
       assignExpression
     | arrayInitializer
     | structInitializer
     | functionBody

 operands ::=
     asmExp+

 outStatement ::=
     'out' ('(' Identifier ')')? blockStatement

parameter ::=
     parameterAttribute* type (Identifier? '...' | (Identifier? ('=' assignExpression)?))?

 parameterAttribute ::=
       typeConstructor
     | 'final'
     | 'in'
     | 'lazy'
     | 'out'
     | 'ref'
     | 'scope'
     | 'auto'

 parameters ::=
       '(' parameter (',' parameter)* (',' '...')? ')'
     | '(' '...' ')'
     | '(' ')'

// TODO 14
// postblit ::=
//     'this' '(' 'this' ')' memberFunctionAttribute* (functionBody | ';')
//     ;

//TODO 13
// postIncDecExpression ::=
//     unaryExpression ('++' | '--')
//     ;



 pragmaDeclaration ::=
     pragmaExpression ';'

 pragmaExpression ::=
     'pragma' '(' Identifier (',' argumentList)? ')'

// TODO 11
// preIncDecExpression ::=
//     ('++' | '--') unaryExpression
//     ;

// TODO 10
 primaryExpression ::=
       identifierOrTemplateInstance
     | '.' identifierOrTemplateInstance
     | builtinType '.' Identifier
     | typeofExpression
     | typeidExpression
     | vector
     | arrayLiteral
     | assocArrayLiteral
     | '(' expression ')'
     | isExpression
     | lambdaExpression
     | functionLiteralExpression
     | traitsExpression
     | mixinExpression
     | importExpression
     | '$'
     | 'this'
     | 'super'
     | 'null'
     | 'true'
     | 'false'
     | '__DATE__'
     | '__TIME__'
     | '__TIMESTAMP__'
     | '__VENDOR__'
     | '__VERSION__'
     | '__FILE__'
     | '__LINE__'
     | '__MODULE__'
     | '__FUNCTION__'
     | '__PRETTY_FUNCTION__'
     | INTEGER_LITERAL
     | FLOAT_LITERAL
     | StringLiteral+
     | CHARACTER_LITERAL

 register ::=
     Identifier
     | Identifier '(' INTEGER_LITERAL ')'

 relOperator ::=
       '<'
     | '<='
     | '>'
     | '>='
     | '!<>='
     | '!<>'
     | '<>'
     | '<>='
     | '!>'
     | '!>='
     | '!<'
     | '!<='
     ;

 returnStatement ::=
     'return' expression? ';'


 scopeGuardStatement ::=
     'scope' '(' Identifier ')' statementNoCaseNoDefault


 sharedStaticConstructor ::=
     'shared' 'static' 'this' '(' ')' functionBody


 sharedStaticDestructor ::=
     'shared' 'static' '~' 'this' '(' ')' functionBody




 singleImport ::=
     (Identifier '=')? identifierChain



// TODO 6
// sliceExpression ::=
//       unaryExpression '[' assignExpression '..' assignExpression ']'
//     | unaryExpression '[' ']'
//     ;

 statement ::=
       statementNoCaseNoDefault
     | caseStatement
     | caseRangeStatement
     | defaultStatement

 staticAssertDeclaration ::=
     staticAssertStatement


 staticAssertStatement ::=
     'static' assertExpression ';'


 staticConstructor ::=
     'static' 'this' '(' ')' functionBody


 staticDestructor ::=
     'static' '~' 'this' '(' ')' functionBody


 staticIfCondition ::=
     'static' 'if' '(' assignExpression ')'


 storageClass ::=
       atAttribute
     | typeConstructor
     | deprecated
     | 'abstract'
     | 'auto'
//     | 'enum'
     | 'extern'
     | 'final'
     | 'nothrow'
     | 'override'
     | 'pure'
     | 'ref'
     | '__gshared'
     | 'scope'
     | 'static'
     | 'synchronized'


 structBody ::=
     '{' declaration* '}'


 structDeclaration ::=
     'struct' Identifier? (templateParameters constraint? structBody | (structBody | ';'))


 structInitializer ::=
     '{' structMemberInitializers? '}'


 structMemberInitializer ::=
     (Identifier ':')? nonVoidInitializer


 structMemberInitializers ::=
     structMemberInitializer (',' structMemberInitializer?)*


 switchStatement ::=
     'switch' '(' expression ')' statement


 symbol ::=
     '.'? identifierOrTemplateChain


 synchronizedStatement ::=
     'synchronized' ('(' expression ')')? statementNoCaseNoDefault


 templateAliasParameter ::=
      'alias' type? Identifier (':' (type | assignExpression))? ('=' (type | assignExpression))?


 templateArgument ::=
       type
     | assignExpression


 templateArgumentList ::=
     templateArgument (',' templateArgument?)*


 templateArguments ::=
     '!' ('(' templateArgumentList? ')' | templateSingleArgument)


 templateDeclaration ::=
       'template' Identifier templateParameters constraint? '{' declaration* '}'
     | eponymousTemplateDeclaration


eponymousTemplateDeclaration ::=
     'enum' Identifier templateParameters '=' assignExpression ';'


 templateInstance ::=
     Identifier templateArguments


 templateMixinExpression ::=
     'mixin' mixinTemplateName templateArguments? Identifier?


 templateParameter ::=
       templateTypeParameter
     | templateValueParameter
     | templateAliasParameter
     | templateTupleParameter
     | templateThisParameter


 templateParameterList ::=
     templateParameter (',' templateParameter?)*


 templateParameters ::=
     '(' templateParameterList? ')'


// TODO 5
 templateSingleArgument ::=
       builtinType
     | Identifier
     | CHARACTER_LITERAL
     | StringLiteral
     | INTEGER_LITERAL
     | FLOAT_LITERAL
     | 'true'
     | 'false'
     | 'null'
     | 'this'
     | '__DATE__'
     | '__TIME__'
     | '__TIMESTAMP__'
     | '__VENDOR__'
     | '__VERSION__'
     | '__FILE__'
     | '__LINE__'
     | '__MODULE__'
     | '__FUNCTION__'
     | '__PRETTY_FUNCTION__'


 templateThisParameter ::=
     'this' templateTypeParameter


 templateTupleParameter ::=
     Identifier '...'


 templateTypeParameter ::=
     Identifier (':' type)? ('=' type)?


 templateValueParameter ::=
     type Identifier (':' expression)? templateValueParameterDefault?


 templateValueParameterDefault ::=
     '=' ('__FILE__' | '__MODULE__' | '__LINE__' | '__FUNCTION__' | '__PRETTY_FUNCTION__' | assignExpression)


 ternaryExpression ::=
     orOrExpression ('?' expression ':' ternaryExpression)?


 throwStatement ::=
     'throw' expression ';'


 traitsExpression ::=
     '__traits' '(' Identifier ',' templateArgumentList ')'


 tryStatement ::=
     'try' declarationOrStatement ((catches finally_?) | finally_)


 type ::=
     attribute? type2 typeSuffix*


 type2 ::=
       builtinType
     | symbol
     | typeofExpression ('.' identifierOrTemplateChain)?
     | typeConstructor '(' type ')'


 typeConstructor ::=
       'const'
     | 'immutable'
     | 'inout'
     | 'shared'
     | 'scope'


 typeConstructors ::=
     typeConstructor+


 typeSpecialization ::=
       type
     | 'struct'
     | 'union'
     | 'class'
     | 'interface'
     | 'enum'
     | 'function'
     | 'delegate'
     | 'super'
     | 'const'
     | 'immutable'
     | 'inout'
     | 'shared'
     | 'return'
     | 'typedef'
     | '__parameters'


 typeSuffix ::=
       '*'
     | '[' type? ']'
     | '[' assignExpression ']'
     | '[' assignExpression '..'  assignExpression ']'
     | ('delegate' | 'function') parameters memberFunctionAttribute*


 typeidExpression ::=
     'typeid' '(' (type | expression) ')'


 typeofExpression ::=
     'typeof' '(' (expression | 'return') ')'


// TODO 4
unaryExpression ::=
      primaryExpression
    | '&' unaryExpression
    | '!' unaryExpression
    | '*' unaryExpression
    | '+' unaryExpression
    | '-' unaryExpression
    | '~' unaryExpression
    | '++' unaryExpression
    | '--' unaryExpression
//    | unaryExpression templateArguments? arguments
//    | unaryExpression '[' assignExpression '..' assignExpression ']'
//    | unaryExpression '[' ']'
//    | unaryExpression '[' argumentList ']'
    | newExpression
    | deleteExpression
    | castExpression
    | assertExpression
    | '(' type ')' '.' identifierOrTemplateInstance
//    | unaryExpression '.' identifierOrTemplateInstance
//    | unaryExpression '--'
//    | unaryExpression '++'


 unionDeclaration ::=
       'union' Identifier templateParameters constraint? structBody
     | 'union' Identifier (structBody | ';')
     | 'union' structBody


 unittest ::=
     'unittest' blockStatement


 variableDeclaration ::=
       type declarator (',' declarator)* ';'
     | type declarator '=' functionBody
     | autoDeclaration


 vector ::=
     '__vector' '(' type ')'


// TODO 3
 versionCondition ::=
     'version' '(' (INTEGER_LITERAL | Identifier | 'unittest' | 'assert') ')'


// TODO 2
 versionSpecification ::=
     'version' '=' (Identifier | INTEGER_LITERAL) ';'


 whileStatement ::=
     'while' '(' expression ')' declarationOrStatement


 withStatement ::=
     'with' '(' expression ')' statementNoCaseNoDefault



  asmAndExp ::=
      asmEqualExp ('&' asmEqualExp)?

 // left recursion rules adjustment

 //addExpression ::=
 //       mulExpression
 //     | addExpression ('+' | '-' | '~') mulExpression

 addExpression ::= mulExpression [('+' | '-' | '~') addExpression]


 // andAndExpression ::=
 //       orExpression
 ////     | andAndExpression '&&' orExpression

  andAndExpression ::= orExpression ['&&' andAndExpression]


 // andExpression ::=
 //       cmpExpression
 ////     | andExpression '&' cmpExpression

  andExpression ::= cmpExpression ['&' andExpression]


 // asmAddExp ::=
 //       asmMulExp
 ////     | asmAddExp ('+' | '-') asmMulExp

  asmAddExp ::= asmMulExp [('+' | '-') asmAddExp]


 // asmBrExp ::=
 //       asmUnaExp
 //     | asmBrExp '[' asmExp ']'

  asmBrExp ::= asmUnaExp ['[' asmExp ']' asmBrExp]


 // mulExpression ::=
 //       powExpression
 //     | mulExpression ('*' | '/' | '%') powExpression

  mulExpression ::= powExpression [('*' | '/' | '%') mulExpression]


 // orExpression ::=
 //       xorExpression
 //     | orExpression '|' xorExpression

 orExpression ::= xorExpression ['|' orExpression]


 // orOrExpression ::=
 //       andAndExpression
 //     | orOrExpression '||' andAndExpression

 orOrExpression ::= andAndExpression ['||' orOrExpression]


 // powExpression ::=
 //       unaryExpression
 //     | powExpression '^^' unaryExpression

  powExpression ::= unaryExpression ['^^' powExpression]


 // relExpression ::=
 //       shiftExpression
 //     | relExpression relOperator shiftExpression

  relExpression ::= shiftExpression [relOperator relExpression]


 // shiftExpression ::=
 //       addExpression
 //     | shiftExpression ('<<' | '>>' | '>>>') addExpression

  shiftExpression ::= addExpression [('<<' | '>>' | '>>>') shiftExpression]


 // xorExpression ::=
 //       andExpression
 //     | xorExpression '^' andExpression

  xorExpression ::= andExpression ['^' xorExpression]
